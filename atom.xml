<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Smiley</title>
  
  <subtitle>The shortest answer is doing the thing.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wsmiley.github.io/"/>
  <updated>2019-07-19T07:58:50.937Z</updated>
  <id>http://wsmiley.github.io/</id>
  
  <author>
    <name>Smiley</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android笔记</title>
    <link href="http://wsmiley.github.io/2019/07/19/Android%E7%AC%94%E8%AE%B0/"/>
    <id>http://wsmiley.github.io/2019/07/19/Android笔记/</id>
    <published>2019-07-19T07:02:16.000Z</published>
    <updated>2019-07-19T07:58:50.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android笔记"><a href="#Android笔记" class="headerlink" title="Android笔记"></a>Android笔记</h1><blockquote><p>学习Android时候，做的一些笔记</p></blockquote><hr><h2 id="关于Android的小结"><a href="#关于Android的小结" class="headerlink" title="关于Android的小结"></a>关于Android的小结</h2><p>Andriod分为四个框架<br></p><ul><li>Linux内核层</li><li>系统运行层</li><li>应用框架层</li><li>应用层</li></ul><p>四大组件<br></p><ul><li>活动(包含用户界面，主要用于和用户交互)</li><li>服务</li><li>广播接收器</li><li>内容提供器</li></ul><p>工程Project文件解释<br><br>1、gradle目录（包含了gradle wrapper的配置文件,使用gradle wrapper的方式不需要提前将gradle下载好，而是会根据本地缓存情况决定是否需要联网下载</p><ul><li>.gitignore  指定的目录或文件排除在版本控制之外</li><li>build.gradle 项目全局的gradle构建脚本</li><li>gradle.properties 全局的gradle配置文件，影响所有gradle编译</li><li>local.properties 指定本机中的Android SDK路径</li><li>settings.gradle 指定项目中所有引入的模块</li></ul><p>2、App目录</p><ul><li>libs 第三方jar包，该目录下的jar包会自动添加到构建路径里</li><li>res目录图片(drawable)布局(layout)字符串、颜色、样式(values)、mipmap(图标)</li><li>AndroidManifest.xml 配置文件</li></ul><p>日志工具<br><br>方法<br></p><blockquote><p>Log.v() 打印琐碎的、意义最小的日志信息。对应级别是verbose</p></blockquote><blockquote><p>Log.d() 打印一些调试信息，这些信息对你的调试程序和分析问题有帮助。对应级别是debug</p></blockquote><blockquote><p>Log.i() 打印一些比较重要的数据，可分析用户行为。对应级别info</p></blockquote><blockquote><p>Log.w() 打印一些警告信息，某个地方存在潜在风险。对应级别warn</p></blockquote><blockquote><p>Log.e() 打印程序的错位信息。对应级别error</p></blockquote><hr><h2 id="活动Activity"><a href="#活动Activity" class="headerlink" title="活动Activity"></a>活动Activity</h2><hr><p>1、手动创建活动</p><blockquote><p>Add No Activity</p></blockquote><blockquote><p>app/src/main/java/com.example.actitvitytest目录为空</p></blockquote><blockquote><p>New - Activity - Empty Activity</p></blockquote><blockquote><p>Generate Layout File:创建对应布局文件</p></blockquote><blockquote><p>Launcher Activity:设置当前创建活动为主活动</p></blockquote><blockquote><p>Backwards Compatibilitiy:项目启用向下兼容模式</p></blockquote><p>2、创建和加载布局</p><li> <strong>创建布局文件<blockquote><p>app/src/main/res</p></blockquote><blockquote><p>New - Directory -创建layout目录 - New - Layout resource file</p></blockquote><blockquote><p>布局元素属性值 match_parent:当前元素与父元素一样宽 wrap_content:   当前元素的高度能刚好包含里面的内容</p></blockquote><li><strong>在AndroidManifest文件中注册<blockquote><p>注册声明放在&lt; application &gt;标签内，通过&lt; activity &gt;标签来对活动注册</p></blockquote><blockquote><p>&lt; intent-filter &gt;标签理解为过滤器，它指定了启动应用程序的Intent对象的动作和类型<br>&lt; action android:name=”android.intent.action.MAIN”/<br>&lt; category android:name=”android.intent.category.LAUNCHER”/&gt;</p></blockquote><li>Toast:提醒方式<blockquote><p>Toast.makeText( FirstActivity.this, string, Toast.LENGTH_SHORT).show()</p></blockquote><blockquote><p>//makeText创建出一个Toast对象，调用show()方法将Toast显示出来。</p></blockquote><p>第一个参数context(Toast要求的上下文，活动本身就是一个context对象)。第二个参数(Toast显示文本对象)。第三个参数(显示时长)</p></li><li>Menu<blockquote><p>res目录 - New - Directory - Menu - New - Menu resource file</p></blockquote><blockquote><p>&lt; item &gt;标签用来创建具体的某一个菜单项</p></blockquote><blockquote><p>Ctrl+O 重写 onCreateOptionsMenu()方法</p></blockquote><blockquote><p>getMenuInflater()方法得到MenuInflater对象，调用它的inflate()方法给当前活动创建菜单。inflate() 第一个参数指定通过哪个资源文件来创建菜单中。第二个参数用于指定我们的菜单项将添加到哪一个Menu对象中</p></blockquote><blockquote><p>响应菜单重写onOptionsSelected()方法,调用item.getItemId()判断点击哪个菜单项</p></blockquote><p>3、<strong>Intent:各组件之间进行交互，不同组件之间传递数据</strong></p></li><li>显式Intent<blockquote><p>Intent(Cotext packageContext,Class&lt;?&gt;cls)<br>//第一个参数Context要求提供一个启动活动的上下文。第二个参数Class则是指定想要启动的目标活动(意图)</p></blockquote><blockquote><p>startActivity()方法启动活动。</p></blockquote></li><li>隐式Intent<blockquote><p>指定一系列更为抽象的action和category等信息，然后交由系统去分析这个Intent，找到合适的活动去启动</p></blockquote><blockquote><p>在AndroidManifest.xml文件中&lt; action &gt;和&lt; category &gt;有关</p></blockquote><pre><code>1、打开浏览器    Intent intent = new Intent(Intent.ACTION_VIEW);    intent.setData(Uri.parse(&quot;url&quot;));//Uri.parse方法将网址字符串解析成一个对象,用setData方法将Uri对象传进去    startActivity(intent);2、拨号    Intent intent = new Intent(Intent.ACTION_DIAL);    intent.setData(Uri.parse(&quot;tel:10086&quot;));//geo表示地理位置    startActivity(intent);3、向下一个活动传递数据    //传值           String data = &quot;Hello world&quot;;    Intent intent = new Intent(Activity.this,Acitivity.class);    intent.putExtra(&quot;extra_data&quot;,data);//第一个参数是键，第二个参数是取值    startAcitvity(intent);    //取值    Intent intent = getIntent();//getIntent()方法得到上一个活动的Intent    String data = intent.getStringExtra(&quot;extra_data&quot;);//调用getStringExtra()传入相应的键值，来获得传递的数据4、返回数据给上一个活动    Intent intent = new Intent(Activity.this,Activity.class);    startActivityForResult(intent,1);//第一个参数Intent，第二个参数是请求码，用于判断在之后的回调中判断数据的来源    Intent intent = new Intent();    intent.putExtra(&quot;data_return&quot;,&quot;hello world&quot;);    setResult(RESULT_OK,intent);//专门用于向上一个活动返回数据的。第一个参数用于向上一个活动返回处理结果的。第二个参数是把带有数据的Intent传递回去    finish();    //重写onActivityResult()方法    onActivityResult(int requestCode,int resultCode,Intent data)    //第一个参数:启动活动时传入的请求码。第二个参数:返回数据时传入的处理结果。第三个参数:携带返回数据的Intent。    //重写onBackPressed()方法</code></pre><p>4、活动的生命周期(返回栈)</p><ul><li>活动状态<ul><li>运行状态</li><li>暂停状态</li><li>停止状态</li><li>销毁状态</li></ul></li><li>活动的生存期<ul><li>onCreate() :活动第一次被创建调用</li><li>onStart() :活动由不可见变为可见调用</li><li>onResume() :活动准备好和用户进行交互时调用，此活动一定位于返回栈的栈顶，并处于运行状态</li><li>onPause() :系统准备启动/恢复另一个活动的时候调用</li><li>onStop() :活动完全不可见时调用</li><li>onDestroy() :活动被销毁之前调用</li><li>onRestart() :活动由停止状态变为运行状态之前调用</li></ul></li></ul><p>5、活动的启动模式</p><p>在AndroidManifest.xml中通过&lt; activity &gt;标签指定android.lanunchMode属性来选择启动模式 </p><blockquote><p>standard：活动默认启动模式.对于standard模式启动的活动，系统不在乎这个是否在返回栈中存在，每次启动都会创建该活动的一个新实例</p></blockquote><blockquote><p>singleTop：启动活动时，若发现返回栈的栈顶是该活动，默认使用该活动，不再创建新实例</p></blockquote><blockquote><p>singleTask 每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现则之间使用该实例，并把活动之上的所有活动统统出栈。如果没有发现就会创建一个新的活动实例</p></blockquote><blockquote><p>singleInstance：启动一个新的返回栈管理这个活动。</p></blockquote><hr><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><ul><li>控件（TextView,Button,EditText,ImageView,ProgressBar,AlerDialog,ProgressDialog)</li><li>布局<br>  1、线性布局(LinearLayout)<br>  2、相对布局(RelativeLayout)<br>  3、帧布局(FrameLayout)<br>  4、百分比布局(PercentFrameLayout)(PercentRelativeLayout)</li><li>自定义控件</li></ul><hr><h2 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h2><ul><li>标准广播 : 完全异步执行的广播，没有先后顺序，几乎同时收到。</li><li>有序广播 : 同步执行的广播，同一时刻只有一个广播接收器能够收到这条广播，当广播接收器中的逻辑执行完后，广播才继续（有优先级、可截断）</li></ul><p>需要进行一些敏感操作，必须在配置文件(AndroidManifest.xml)中声明权限</p><p>1、系统广播</p><ul><li>动态注册：代码中注册。</li></ul><blockquote><p>新建一个类继承BroadcastReceiver，重写onReceive()方法。</p></blockquote><blockquote><p>动态注册的广播接收器一定都要取消注册。 在onDestroy()方法中调用unregisterReceiver()方法实现。</p></blockquote><ul><li>静态注册：在AndroidManifest.xml中注册</li></ul><blockquote><p>&lt; application &gt;标签内 &lt; receiver &gt;所有静态的广播接收器都是在这里注册的</p></blockquote><p>不要在onReceive()方法中添加过多的逻辑或者进行任何耗时操作，因为广播接收器是不允许开启线程的，当onReceive()方法运行过长时间而没有结束，程序就会报错。</p><p>2、本地广播：广播只在应用程序内部传递，广播接收器也只接收来自本应用程序发出的广播。（安全性）。无法通过静态注册的方式接收。</p><blockquote><p>LocalBroadcastManager //对广播进行管理，并提供了发生广播和注册广播接收器的方法。</p></blockquote><hr><h2 id="数据存储——持久化技术"><a href="#数据存储——持久化技术" class="headerlink" title="数据存储——持久化技术"></a>数据存储——持久化技术</h2><p>简介：数据持久化就是指那些内存中的瞬时数据保存到数据存储设备中，保证即使在手机或电脑关机的情况下，这些数据仍不会丢失。持久化技术提供了一种机制可以让数据在瞬时状态和持久之间进行转换。</p><ul><li>文件存储</li><li>SharedPreferences存储</li><li>数据库存储</li></ul><h3 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h3><p>特点：不对存储的内容进行任何的格式化处理，所有数据都是原封不动地保存到文件中，因而比较适合用于存储一些简单的文本数据或二进制数据。</p><p>1、将数据存储到文件中</p><blockquote><p>Context类提供了一个openFileOutput()方法,用于将数据存储到指定的文件中。第一个参数文件名(不可以包含路径)，所有文件默认存储到/data/data/&lt; package name &gt;/files/。第二个参数是文件的操作模式.MODE_PRIVATE/MODE_APPEND。返回一个FileOutputStream对象，得到对象后用Java流的方式将数据写入文件。</p></blockquote><p>2、从文件中读取数据</p><blockquote><p>Context类提供一个openFileInput()方法，用于从文件中读取数据。只接收一个参数，要读取的文件名。返回一个FileInputStream对象。得到对象之后通过Java流的方式将数据读取。</p></blockquote><h3 id="SharedPreferences存储"><a href="#SharedPreferences存储" class="headerlink" title="SharedPreferences存储"></a>SharedPreferences存储</h3><p>特点:利用键值对的方式存储数据，支持多种不同的数据类型存储。</p><blockquote><p>首先得到SharedPreferences对象</p></blockquote><ul><li>有三种方法得到sharedPreferences对象</li></ul><p>1、Context类中的getSharedPreferences()方法，此方法接收两个参数。第一个参数用于指定SharedPreferences文件的名称；如果指定不存在，则会创建一个。SharedPreferences文件存放在/data/data/&lt; package name &gt;/shared_prefs/目录下。第二个参数用于指定操作模式：MODE_PRIVATE</p><p>2、Activity类中的getpreferences()方法<br>与Context中getPreferences方法类似。不过它只接收一个操作模式参数，这个方法会自动将当前活动的类名作为SharePrefereces的文件名。</p><p>3、PreferenceManager类中的getDefaultSharedPreferences()方法<br>这是一个静态方法。接收一个Context参数，并自动使用当前应用程序的包名作为前缀来命名SharedPreference文件。<br>分为三步</p><ul><li>调用SharedPreferences对象的Edit()来获取一个SharedPreferences.Editor对象。</li><li>向SharedPreferences.Editor对象中添加数据。</li><li>调用apply()方法将添加的数据提交，从而完成数据存储操作</li></ul><h3 id="SQLite数据库存储"><a href="#SQLite数据库存储" class="headerlink" title="SQLite数据库存储"></a>SQLite数据库存储</h3><p>Android内置数据库SQLite，有专门管理数据库的一个类SQLiteOpenHelper(抽象类)帮助类</p><blockquote><p>首先创建一个自己的帮助类继承SQLiteOpenHelper抽象类</p></blockquote><blockquote><p>SQLiteOpenHelper有两个抽象方法。在自己的帮助类重写onCreate()方法和onUpgrade()方法</p></blockquote><blockquote><p>SQLiteOpenHelper两个实例方法：getReadableDatabase()和getWritableDatabase()。<br>两个方法可以创建/打开一个现有的数据库(存在打开，否则创建)，并且返回一个可对数据库进行读写操作的对象SQLiteDatabase。</p></blockquote><p>不同:当数据库不可写入时，getReadableDatabase()方法返回的对象将以只读的方式打开数据库。getWritableDatabase()方法则出现异常。</p><h3 id="LitePal操作数据库"><a href="#LitePal操作数据库" class="headerlink" title="LitePal操作数据库"></a>LitePal操作数据库</h3><p>简介:Litepal是一款开源的Android数据库框架,采用对象关系映射(ORM)的模式,并将平时开放最常用到的一些数据库功能进行封装。<a href="https://github.com/LitePalFramework/LitePal" target="_blank" rel="noopener">https://github.com/LitePalFramework/LitePal</a></p><ul><li>配置LitePal</li></ul><blockquote><p>app/built.gradle——dependecies闭包中添加<br>dependencies{<br>mplementation ‘org.litepal.android:java:3.0.0’<br>}</p></blockquote><ul><li>配置Litepal.xml文件<blockquote><p>app/src/main——new-Directory创建一个assets目录-创建litepal.xml文件</p></blockquote></li></ul><p>编辑</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt; litepal &gt;</span><br><span class="line">    &lt; dbname value=&quot;bookStore&quot;&gt;&lt; /dbname&gt; //用于指定数据库名</span><br><span class="line">    &lt; version value=&quot;1&quot;&gt;&lt; /version&gt;   //用于指定数据库版本号</span><br><span class="line">    &lt; list&gt;  //用于指定所有的映射模型</span><br><span class="line">    &lt; /list&gt;</span><br><span class="line">&lt; /litepal&gt;</span><br></pre></td></tr></table></figure><ul><li>编辑AndroidmaniFest.xml文件<blockquote><p>&lt; application<br>  android:name=”org.litepal.LitePalApplication&gt;</p></blockquote></li></ul><hr><h2 id="内容提供器"><a href="#内容提供器" class="headerlink" title="内容提供器"></a>内容提供器</h2><p>简介:内容提供器主要用于在不同的应用程序之间实现数据共享的功能。它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保住被访问数据的安全性。（可以选择只对哪一部分数据进行共享</p><p>用法：(1)使用现有的内容提供器来读取和操作相应程序中的数据。(2)创建自己的内容提供器给程序的数据提供外部访问接口。</p><h3 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h3><ul><li>普通权限</li><li>特殊权限</li><li>危险权限</li></ul><p>完整权限列表 http//developer.android.google.cn/reference/android/Manifest.permission.html</p><h4 id="运行时申请权限"><a href="#运行时申请权限" class="headerlink" title="运行时申请权限"></a>运行时申请权限</h4><p>AndroidManifest.xml</p><blockquote><p>&lt; uses-permission android:name=””&gt;</p></blockquote><p>MainActivity——逻辑<br>第一步判断是否拥有权限</p><blockquote><p>ContextCompat.checkSelfPermission()方法。接收两个参数，第一个参数Context。第二个参数是具体的权限名，然后返回值和PackageManager.xxx做比较</p></blockquote><p>若无权限</p><blockquote><p>调用ActivityCompat.requestPermission()方法来向用户申请权限。接收三个参数。第一个参数是Activity的实例；第二个参数是String数组，把申请的权限名放在数组中；第三个参数是请求码，要求唯一值。</p></blockquote><h3 id="访问其他程序中的数据"><a href="#访问其他程序中的数据" class="headerlink" title="访问其他程序中的数据"></a>访问其他程序中的数据</h3><h4 id="ContentResolver类"><a href="#ContentResolver类" class="headerlink" title="ContentResolver类"></a>ContentResolver类</h4><p>用法:想要访问内容提供器中共享的数据，必须借助ContentResolver类，通过Context中的getContentResolver()方法获取该到该类的实例。ContentResolver中提供了一系列的方法用于对数据进行CRUD操作</p><ul><li>insert()添加数据</li><li>updata()更新数据</li><li>delete()删除数据</li><li>query()查询数据</li></ul><p>ContentResolver中的增删改查不接收表名参数，接收一个Uri参数(内容URI:表达了哪个程序中的哪张表里的数据)。<br>内容URI给内容提供器建立了唯一的标识符。由两部分组成：authority和path。<br>authority:用于对不同的应用程序做区分，一般为了避免冲突，都会采用程序包名的方式来进行命名。<br>path:用于对同一张表table1和table2，可以用path分别命名为/table1和table2,然后把authority和path进行组合。</p><p>得到内容URI字符串后，将它解析成Uri对象才可以做为参数传入。调用Uri.parse()方法，就可以将内容URI字符串解析成Uri对象</p><blockquote><pre><code>Uri uri=Uri.parse(&quot;content:comple.app.provider/table1&quot;)Cursor cursor=getContentResolver().query(uri,//指定某个应用程序下的某一张表projection,//查询的列名selection,//where的约束条件selectionArgs,//where中的占位符提供具体的值sortorder);//查询结果的排序方式</code></pre></blockquote><p>查询结果返回一个Cursor对象，数据可以从Cursor对象中逐个读取出来了。</p><h4 id="创建自己的内容提供器"><a href="#创建自己的内容提供器" class="headerlink" title="创建自己的内容提供器"></a>创建自己的内容提供器</h4><p>新建一个类去继承ContenProvider：有六个抽象方法<br></p><ul><li>onCreate():初始化内容提供器时调用。通常会在这里完成对数据库的创建和升级操作</li><li>query():从内容提供器中查询数据。uri确定查询哪张表，projection确定查询哪些列，selection和selectionArgs用于约束哪些行，sortorder用于对结果进行排序，查询结果存放在Cursor对象中返回。</li><li>insert():向内容提供器中添加一条数据。使用uri参数来确定添加到的表，待添加的数据保存在values参数中，添加完成后，返回一个用于表示这条新数据的URI</li><li>update():更新内容提供器的已有数据。使用uri参数来确定更新表中那些数据，待添加的数据保存在values参数中，selection和selectionArgs用于约束更新哪些行，受影响的行数将作为返回值返回。</li><li>delete():从内容提供器中删除数据。uri确定删除哪张表中的数据，selection和selectionArgs用于约束删除哪些行，被删除的行数将作为返回值返回。</li><li>getType():根据传入进入的内容URI来返回相应的MIME类型。</li></ul><p>MIME类型字符串由三部分组成。格式</p><ul><li>必须以vnd开头。</li><li>如果内容URI以路径结尾，则后接android.cursor.dir/；如果以id结尾,则后接android.cursor.item/</li><li>最后接上vhd.&lt; authoriy &gt;.&lt; path &gt;</li></ul><p>内容URI的格式,以路径结尾就表示期望访问该表中所有的数据，以id结尾就表示期望访问该表中拥有相应id的数据。<br><br>通配符<br><br>*:表示匹配任意长度字符。<br></p><p>#：表示匹配任意长度的数字。</p><blockquote><p>content://com.exmaple.app.provider/table1/#</p></blockquote><p>UriMatcher类:实现匹配内容URI的功能。</p><p>uriMatcher.addURI()方法：接收三个参数，authority,path和一个自定义代码。</p><p>uriMatcher.match()方法:传入一个Uri对象，返回值是某个能够匹配这个Uri对象所对应的自定义代码，利用这个代码可以判断出调用方期望访问的哪张表中的数据了。</p><p>跨程序访问不能直接使用Toast。</p><hr><h2 id="运用手机多媒体"><a href="#运用手机多媒体" class="headerlink" title="运用手机多媒体"></a>运用手机多媒体</h2><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><h4 id="创建通知"><a href="#创建通知" class="headerlink" title="创建通知"></a>创建通知</h4><p>1、首先需要一个NotificationManager对通知进行管理，调用Context的getSystemService()方法获得。getSystemService()接收一个字符串参数用于确定获取系统的哪个服务。</p><blockquote><p>NotificationManager manager=(NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);</p></blockquote><p>2、接下来使用一个Builder构造器来创建Notification对象。support-v4库中提供了一个NotificationCompat类，使用这个类的构造器创建Notification对象。</p><blockquote><p>Notification notification=new NotificationCompat.Builder(context).build();</p><ul><li>setContentTitle(“”):通知的标题</li><li>setContext(“”):通知的正文内容</li><li>SetWhen():通知被创建的时间</li><li>SetSmallIcon():设置通知的小图标，注意只能使用纯alpha图层的图片进行设置(状态栏)</li><li>SetLargeIcon():设置通知的大图标。(下拉)</li></ul></blockquote><p>完成后只要调用NotificationManager的notify()方法就可以让通知显示出来，接收两个参数，第一个参数id：保证每个通知所指定的id都是不同的。第二个参数是Notification对象。</p><hr><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>Android发送HTTP请求:HttpURLConnection和OkHttp</p><p>###HttpURLConnection<br>获取HttpURLConnection实列</p><blockquote><p>URL url=new URL(“http://…”);<br>HttpURLConnection connection=(HttpURLConnection)url.openConnection();</p></blockquote><p>得到HttpURLConnection实例后，设置HTTP请求所用的方法，GET和POST。</p><ul><li>GET：从服务器中获取数据</li><li>POST：提交数据给服务器<blockquote><p>connection.setRequestMethod(“GET”);</p></blockquote></li></ul><p>其他定制：例如设置连接超时，读取超时的毫秒数，以及服务器希望得到的一些消息头。</p><blockquote><p>connection.setConnectTimeout(8000);<br>connection.setReadTimeout(8000);</p></blockquote><p>调用getInpuStream()方法获取到服务器返回的输入流.</p><blockquote><p>InpuStream in=connection.getInputStream();</p></blockquote><p>用disconnect()方法将这个HTTP连接关闭掉</p><blockquote><p>connection.disconnect();</p></blockquote><p>控件：ScrollView：滚动形式查看屏幕外的内容</p><p>###OkHttp<br>项目地址<a href="http://github.com/square/okhttp" target="_blank" rel="noopener">http://github.com/square/okhttp</a><br>添加Okhttp库依赖<br>编辑app/build.gradle文件<br>在dependencies闭包中添加</p><blockquote><pre><code> dependencies{       implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])       implementation &apos;com.android.support:appcompat-v7:28.0.0&apos;       testImplementation &apos;junit:junit:4.12&apos;       implementation &apos;com.squareup.okhttp3:okhttp:3.13.1 &apos;}</code></pre></blockquote><p>创建一个OkHttpClient的实例</p><blockquote><p>OkHttpClient client=new OkHttpClient();</p></blockquote><p>发起一条HTTP请求，需要创建Request对象</p><blockquote><p>Request request=new Request.Builder().build();//创建空的Request对象.<br>可以在build()前连缀很多其他方法丰富Request对象</p></blockquote><p>之后调用OkHttpClient的newCall()方法创建一个call对象，并调用它的execute()方法来发送请求并获取服务器返回的数据。Response对象就是服务器返回的数据了。</p><blockquote><p>Response response=client.newCall(request).execute()<br>String responseData=response.body().string();</p></blockquote><p>POST请求<br>首先构建一个RequestBody对象存放待提交的参数。</p><blockquote><p>RequestBody requestBody=new FormBody,Builder().add(“username”,”admin”).add(“password”,”123456”).build();</p></blockquote><p>然后在Request.Builder中调用一下post()方法，并将RequestBody()对象传入。</p><blockquote><p>Request request=new Request.Builder().url(“<a href="http://www.baidu.com&quot;).post(requestBody).build()" target="_blank" rel="noopener">http://www.baidu.com&quot;).post(requestBody).build()</a>;</p></blockquote><p>调用execute()方法来发送请求获取服务器返回的数据。</p><h3 id="解析XML格式数据"><a href="#解析XML格式数据" class="headerlink" title="解析XML格式数据"></a>解析XML格式数据</h3><p>网上常用格式:XML和JSON  （DOM解析方法）</p><h4 id="XML解析"><a href="#XML解析" class="headerlink" title="XML解析"></a>XML解析</h4><h5 id="PULL解析"><a href="#PULL解析" class="headerlink" title="PULL解析"></a>PULL解析</h5><p>调用 parseXMLWithPull() 方法解析服务器返回的数据，传入服务器返回的数据。<br>首先获取一个XmlPullParserFactory的实例，并借助这个实例得到XmlPullParser对象，然后调用XmlPullParser的setInput()方法将服务器返回的XML数据设置进去进行解析。<br>解析过程：通过getEventType()得到当前解析事件，然后一个while循环中不断解析，如果当前解析事件不等于XmlPullParser.END_DOCUMENT,说明解析工作还没有完成,调用next()方法后可以获取下一个解析事件。</p><blockquote><pre><code>private void parseXMLWithPull(String xmlData){    XmlPullParserFactory factory = XmlPullParserFactory.newInstance();    XmlPullParser xmlPullParser = factory.newPullParser();    xmlPullParser.setInput(new StringReader(xmlData));    int eventType = xmlPullParser.getEventType();    while(eventType != XmlPullParser.END_DOCUMENT){     ...    }}</code></pre></blockquote><h5 id="SAX解析"><a href="#SAX解析" class="headerlink" title="SAX解析"></a>SAX解析</h5><p>新建一个类继承DefaultHandler，并重写父类5个方法</p><ul><li>startDocumnet() :开始XML解析时调用</li><li>startElement() :开始解析某个节点的时候调用</li><li>characters() :获取节点中内容的时调用</li><li>endElement() :完成某个节点时候调用</li><li>endDocument() :完成整个XML解析时候调用</li></ul><h4 id="JSON解析"><a href="#JSON解析" class="headerlink" title="JSON解析"></a>JSON解析</h4><p>JSONObject(官方),GSON(Google),Jackson,FastJSON等</p><h5 id="JSONObject"><a href="#JSONObject" class="headerlink" title="JSONObject"></a>JSONObject</h5><p>将从服务器得到的数据返回到parseJSONWithJSONObject()中进行数据解析.<br>在该方法中将数据返回给一个JSONArray对象中，然后遍历循环这个JSONArray,从中取出每一个元素都是一个JSONObject对象。然后调用getString()方法将数据取出</p><blockquote><pre><code>  private void parseJSONWithJSONObject(String jsonData){      try{           JSONArray jsonArray = new JSONArray(jsonData);           for(int i=0;i&lt;jsonArray.length();i++){           JSONObject jsonobject=jsonArray.getJSONObject(i);           ...      }  }}</code></pre></blockquote><h5 id="GSON"><a href="#GSON" class="headerlink" title="GSON"></a>GSON</h5><p>添加GSON库的依赖，编辑app/build.gradle文件</p><blockquote><pre><code>dependencies{     compile &apos;com.google.code.gson:gson:2.7&apos;             }</code></pre></blockquote><p>JSON格式的数据如</p><blockquote><pre><code>{&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:20}</code></pre><p>定义一个Person类，加入name和age这两个字段，然后调用以下代码就可以将JSON数据自动解析成一个Person对象了<br>      Gson gson =new Gson();<br>      Person person = gson.fromJson(jsonData,person.class);</p></blockquote><p>如何解析的是一段JSON数组，借助TypeToken将期望解析成的数据类型传入到fromJson()方法中</p><blockquote><pre><code>List&lt; person &gt;people =gson.fromJson(jsonData,new TypeToken&lt;List&lt;Person&gt;&gt;(){}.getType());</code></pre></blockquote><hr><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>服务是Android中实现程序后台运行的解决方案<br>不自动开启线程，所有代码默认运行在主线程中。</p><h3 id="Android多线程编程"><a href="#Android多线程编程" class="headerlink" title="Android多线程编程"></a>Android多线程编程</h3><p>定义一个线程只需要新建一个类继承自Thread。然后重写父类的run()方法，并在里面下逻辑</p><blockquote><pre><code>class MyThread extends Thread{    public void run(){    }}</code></pre></blockquote><p>启动线程：new出MyThread的实例，然后调用start()方法</p><blockquote><pre><code>new MyThread().start()</code></pre></blockquote><p>使用继承耦合性(?)高，一般使用实现Runnable接口的方式定义一个线程</p><blockquote><pre><code>class MyThread implements Runnable{    public void run(){    }   }</code></pre></blockquote><p>启动线程变不同</p><blockquote><pre><code>MyThread myThread = new MyThread();new Thread(myThread).start();</code></pre></blockquote><p>不使用接口，使用匿名类</p><blockquote><pre><code>  new Thread(new Runnable){       public void run(){       }}</code></pre></blockquote><p>UI无法在子线程里更新，对于这种情况Android提供了一套异步消息处理机制，使得可以在子线程里更新UI。</p><p>Android的异步消息处理主要由4部分组成:Message、Handler、MessageQueue和Looper.</p><ul><li><p>Message:在线程之间传递消息，它内部可以携带少量信息，用于不同线程之间交换数据。</p></li><li><p>Handler：主要用于发送和处理消息。发消息一般是Handler的sendMessage()方法，发出消息后最终传递到Handler的handleMessage()方法中</p></li><li><p>MessageQueue：消息队列，主要用于存放所有通过Handler发送的消息，这部分消息一直放在消息队列中，等待处理，每一个线程中只会有一个MessageQueue对象。</p></li><li><p>Looper:是每一个线程中MessageQueue的管理者，调用Looper的loop()方法后，就会进入到一个无限循环中，然后发现MessageQueue中存在一条消息，就会将它取出，传递到Handler的handleMessage()方法中，每一个线程中只有一个Looper对象。</p></li></ul><h3 id="AsyncTask-抽象类"><a href="#AsyncTask-抽象类" class="headerlink" title="AsyncTask:抽象类"></a>AsyncTask:抽象类</h3><p>AsyncTask,是android提供的轻量级的异步类,可以直接继承AsyncTask,在类中实现异步操作,并提供接口反馈当前异步执行的程度(可以通过接口实现UI进度更新),最后反馈执行的结果给UI主线程.</p><p>创建子类继承,继承时可以为AsyncTask类指定3个泛型参数</p><ul><li>Params:在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。比如HTTP请求的URL</li><li>Progress:后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位</li><li>Result:当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型.</li></ul><blockquote><pre><code>class DownloadTask extends AsyncTask&lt;void,Integer,Boolean&gt;{    ...    }</code></pre></blockquote><p>一般重写4个方法</p><ul><li>onPreExecute():这个方法在后台任务开始执行之前调用，用于进行一些界面上的初始化操作。比如显示一些进度条对话框</li><li>doInBackground(Params…):这个方法中的所有代码都会在子线程中运行，应该在这里去处理所有的耗时任务，通过return将任务的执行结果返回.如果AsyncTask的第三个参数是void，则可以不返回任务执行结果。这个方法不可以进行UI操作。如果需要更新UI元素，比如说反馈当前任务执行进度，调用publishProgress(Progress)方法完成。</li><li>onProgressUpdate(Progress…):当任务调用了publishProgress(Progress)后，此方法很快被调用，该方法中携带的参数就是后台任务中传递过来的。可以对UI进行操作，参数中的数值可对界面中的元素进行相应更新。</li><li>onPostExecute(Result):当后台任务执行完毕后并通过return语句进行返回时，该方法很快被调用，返回的数据会被作为参数传递到此方法中，可以利用返回的数据来进行一些UI操作，比如提醒任务执行的结果，以及关闭进度条对话框等。</li></ul><h3 id="服务的基本用法"><a href="#服务的基本用法" class="headerlink" title="服务的基本用法"></a>服务的基本用法</h3><blockquote><p>com.example.servicetest——New——Service——Service<br>Export：表示是否允许除了当前程序之外的程序访问该服务<br>Enalbe：是否启用这个服务</p></blockquote></li></strong></li></strong></li>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android笔记&quot;&gt;&lt;a href=&quot;#Android笔记&quot; class=&quot;headerlink&quot; title=&quot;Android笔记&quot;&gt;&lt;/a&gt;Android笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;学习Android时候，做的一些笔记&lt;/p&gt;
&lt;/bloc
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React</title>
    <link href="http://wsmiley.github.io/2019/07/19/React/"/>
    <id>http://wsmiley.github.io/2019/07/19/React/</id>
    <published>2019-07-19T06:28:46.000Z</published>
    <updated>2019-07-19T07:01:18.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><blockquote><p>学习React的一些笔记</p></blockquote><hr><h2 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h2><h3 id="安装Node-JS"><a href="#安装Node-JS" class="headerlink" title="安装Node.JS"></a>安装Node.JS</h3><p>作为内置工具&gt;Node包管理&gt;npm&gt;安装第三方库</p><p>访问<strong>nodejs.org</strong>安装</p><pre><code>npm -i(代表的是install) -g(代表全局) creat-react-app</code></pre><p>webpack&gt;打包代码</p><p>Babel&gt;转译器转换代码</p><hr><h3 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h3><p>map()函数</p><p>Arrow function函数</p><pre><code>析构const address={    street:&apos;&apos;,    city:&apos;&apos;,    country:&apos;&apos;,}const street=address.street;const city=address.city;const country=address.country;==const {street,city,county}=address;若想使用其他常量const {street:st}=address;</code></pre><p>展开操作符 ‘…’</p><h4 id="引入bootstrap-同理引用第三方库"><a href="#引入bootstrap-同理引用第三方库" class="headerlink" title="引入bootstrap(同理引用第三方库)"></a>引入bootstrap(同理引用第三方库)</h4><pre><code>npm i bootstrapimport &apos;bootstarp/dist/css/boostrap.css&apos;</code></pre><hr><h3 id="React-JSX语法"><a href="#React-JSX语法" class="headerlink" title="React JSX语法"></a>React JSX语法</h3><p>render():渲染&gt;调用React.createElement(参数),所以render里面只有一个顶级元素</p><p>state:是react组件中一个特殊的属性,它包含了这个组件需要用到的数据。</p><h4 id="渲染列表"><a href="#渲染列表" class="headerlink" title="渲染列表"></a>渲染列表</h4><pre><code>{this,state,tags.map(tag=&gt;&lt;li&gt;{tag}&lt;/li&gt;)}</code></pre><p><strong>注意，列表需要设置key属性,且在列表唯一</strong></p><h4 id="有条件渲染"><a href="#有条件渲染" class="headerlink" title="有条件渲染"></a>有条件渲染</h4><pre><code>function(){    if(this.state.)return ;}render(){    return &lt;div&gt;{this.function()}&lt;/div&gt;}</code></pre><p>js中的 &amp;&amp;表达式 看第一个表达式为真,看第二个表达式,若不为布尔表达式，JS编译器尝试转换成类真/类假值,空字符串被视为类假的,一个非空的字符串视为类真的,返回第二个类真值</p><pre><code>function(){    statement...    this指代的对象不同,无法直接访问this.state    可以用在constructor中this.function.bind(this)方法绑定this    第二个方法使用箭头函数：不会重新绑定this，而是继承它}function=()=&gt;{    可以引用this}</code></pre><h4 id="更新状态"><a href="#更新状态" class="headerlink" title="更新状态"></a>更新状态</h4><p>this.setState():传入一个对象,对象的属性会与state中的合并或者当state中有相同的属性，就会被覆盖掉</p><h4 id="如何发起及处理事件-Raise-and-Handle-Eve"><a href="#如何发起及处理事件-Raise-and-Handle-Eve" class="headerlink" title="如何发起及处理事件 Raise and Handle Eve"></a>如何发起及处理事件 Raise and Handle Eve</h4><p>事件点击</p><pre><code>function=()=&gt;{    statement;}    onClick={()=&gt;this.function()}删除一个内容,新建一个数组,包括所有原数组的内容,除了删除按个const xxx=this.state.xxx.filter(m=&gt;m._id!==movie_id)this.setState({xxx:xxx})新传入的xxx数组会覆盖原来的数组</code></pre><h4 id="组件间传递数据-Pass-Data"><a href="#组件间传递数据-Pass-Data" class="headerlink" title="组件间传递数据 Pass Data"></a>组件间传递数据 Pass Data</h4><p>每个组件都有一个叫props属性，属于JS对象，它会拥有向某组件<strong>传递</strong>的所有属性</p><p>传递子元素<br>    <element><br>    <x></x><br>    </element><br>在element组件中可以使用{this.props.children}引用</p><h4 id="多组件保存同步-Multiple-Components-in-Sync"><a href="#多组件保存同步-Multiple-Components-in-Sync" class="headerlink" title="多组件保存同步 Multiple Components in Sync"></a>多组件保存同步 Multiple Components in Sync</h4><p>prop和State区别 </p><ul><li>props是我们给组件的数据(<strong>只读</strong>)</li><li>state是组件本地或者私有的数据容器(只能给本地组件访问)</li></ul><p>受控组件：没有自己的state 所有数据来源props,数据需要改变时发起事件。<br>onClick={()=&gt;this.props.function()}</p><h4 id="功能性组件-Functional-Components"><a href="#功能性组件-Functional-Components" class="headerlink" title="功能性组件 Functional Components"></a>功能性组件 Functional Components</h4><p>无状态功能性组件 Stateless Functional Components</p><ul><li>只有返回方法的组件</li><li>没有事件句柄</li><li>没有state,只从props获取数据 </li></ul><p>可以不使用类定义而使用函数，若要使用props数据，把props当做参数传递即可<br>const function=(props)=&gt;{<br>    statement;<br>    return();<br>}</p><h4 id="生命周期钩子-Lifecycle-Hooks"><a href="#生命周期钩子-Lifecycle-Hooks" class="headerlink" title="生命周期钩子 Lifecycle Hooks"></a>生命周期钩子 Lifecycle Hooks</h4><p>mounting状态(装载阶段)有3个生命钩子</p><ul><li><p>constructor:必须调用super();当一个类的实例创建的时候调用,一般给属性赋值;把state设置为props某些属性</p></li><li><p>render</p></li><li><p>componentDidMount:Ajax与服务器通信</p></li></ul><p>update状态(state或者组件的props改变时发生)</p><ul><li>render</li><li>componentDidUpdate</li></ul><p>unmounting状态(卸载阶段)(组件从DOM中移除)</p><ul><li>componentWillUnmount</li></ul><h4 id="loadsh库"><a href="#loadsh库" class="headerlink" title="loadsh库"></a>loadsh库</h4><p>import _ from ‘lodash’ //约定 _ 代表lodash</p><h4 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h4><p>复用组件使用</p><p>安装prop-types库</p><pre><code>npm i prop-types</code></pre><p>组件创建一个新的属性,在这个属性中定义类型检测的需求</p><pre><code>组件名称.propTypes={    //一般是props传递过来的值     xxx:ProTypes. //后面紧跟的是需要检测的类型(数字,字符串,布尔,数组) xxx析构对象/props传递过来的值}</code></pre><h4 id="props默认值"><a href="#props默认值" class="headerlink" title="props默认值"></a>props默认值</h4><pre><code>组件名.defaultProps={    属性:属性值}</code></pre><hr><h2 id="Routing-and-Navigation"><a href="#Routing-and-Navigation" class="headerlink" title="Routing and Navigation"></a>Routing and Navigation</h2><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><pre><code>npm i react-router-dom 在index.js里import {BrowserRouter} from &apos;react-route-dom&apos;;ReactDOM.render(&lt;BrowerRouter&gt;&lt;App/&gt;&lt;/BrowerRouter&gt;,document.getElementById(&quot;root&quot;));&lt;BrowerRouter&gt;&lt;/BrowerRouter&gt;组件记录了浏览器的历史，并传入各组件树成员import {Rounte} from &apos;react-route-dom&apos;;&lt;Route path=&quot;&quot; component={}&gt; //path 指定路由的匹配规则 component 指定组件</code></pre><p>1、在<route>里加入 exact表示这条规则只会在完全匹配的时候起效</route></p><p>2、引入import {Switch} from ‘react-route-dom’;</p><pre><code>&lt;Switch&gt;会匹配第一条符合的子规则</code></pre><p>&lt; Link &gt;用于取代&lt; a &gt;生成一个链接,to属性</p><p>如何传递props。不使用component改用render={(props)=&gt;{&lt;组件名 属性=属性值 &gt;}}</p><h3 id="Query-String"><a href="#Query-String" class="headerlink" title="Query String"></a>Query String</h3><p>查询字符串就是在URL中加入?  </p><pre><code>npm i query-string  </code></pre><h3 id="Redirect-amp-amp-Not-Found-404-Pages"><a href="#Redirect-amp-amp-Not-Found-404-Pages" class="headerlink" title="Redirect  &amp;&amp;  Not Found(404) Pages"></a>Redirect  &amp;&amp;  Not Found(404) Pages</h3><pre><code>import {Redirect} from &apos;react-router-dom&apos;; //Redirect组件可以重定向网页到另一个页面&lt;Route path=&quot;/not-found&quot; component={NotFound}&gt; //not-found是自己创建的一个组件&lt;Redirect to=&quot;/not-found /&gt;&lt;Redirect from=&quot;message&quot; to=&quot;posts&quot;&gt; //如果用户URL来自message 则跳转到posts</code></pre><h3 id="Nested-Rounting"><a href="#Nested-Rounting" class="headerlink" title="Nested Rounting"></a>Nested Rounting</h3><hr><h2 id="Form"><a href="#Form" class="headerlink" title="Form"></a>Form</h2><h3 id="Handing-Form-Submission—处理表单的提交行为"><a href="#Handing-Form-Submission—处理表单的提交行为" class="headerlink" title="Handing Form Submission—处理表单的提交行为"></a>Handing Form Submission—处理表单的提交行为</h3><p>每一个表单都有onSubmit={this.handleSubmit}方法</p><pre><code>handleSubmit=e=&gt;{    e.preventDefault();//阻止事件的默认行为：阻止向服务器提交表单造成整个页面重载}</code></pre><p>Ref引用(尽量少使用)</p><pre><code>xxx = React.createRef();//创建Ref对象然后在组件中添加ref属性 ref={this.xxx}在handleSubmit方法中需要操作真实DOM则const xxx=this.xxx.current.value; //current返回当前的DOM元素 value属性来得到值</code></pre><h3 id="Validation——验证"><a href="#Validation——验证" class="headerlink" title="Validation——验证"></a>Validation——验证</h3><h4 id="Joi第三方库"><a href="#Joi第三方库" class="headerlink" title="Joi第三方库"></a>Joi第三方库</h4><pre><code>npm i joi-browserimport Joi from &apos;joi-browser&apos;;</code></pre><p>定义一个schema对象</p><pre><code>schema={    username:Joi.string().required().label(&apos;Username&apos;),    password:Joi.string().required().label(&apos;Password&apos;),};</code></pre><p>调用Joi.validate(this.state.xxx,this.schema,{abortEarly:false})方法,第一个参数是我们想要验证的东西,第二个参数是Schema，{abortEarly:false}</p><p>将Joi的结果映射到errors对象中</p><pre><code>const result=Joi.validate(this.state.xxx,this.schema,{abortEarly:false});if(!result.error)return null;const errors={};for(let item of result.error.details)    errors[item.path[0]]=item.message;return errors;</code></pre><hr><h3 id="Calling-Backend-Services"><a href="#Calling-Backend-Services" class="headerlink" title="Calling Backend Services"></a>Calling Backend Services</h3><h4 id="JSONPlaceholder-——伪造的后端-——JSON占位器"><a href="#JSONPlaceholder-——伪造的后端-——JSON占位器" class="headerlink" title="JSONPlaceholder ——伪造的后端 ——JSON占位器"></a>JSONPlaceholder ——伪造的后端 ——JSON占位器</h4><p>一个伪造的在线REST API  应用接口</p><p>React中没有向服务器发送HTTP请求的概念,所以可以自由的选择第三方库</p><ul><li>Fetch API</li><li>jQuery AJAX</li><li>Axios</li></ul><blockquote><p>npm i axios</p></blockquote><hr><h4 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h4><h5 id="Getting-Data"><a href="#Getting-Data" class="headerlink" title="Getting Data"></a>Getting Data</h5><p>获取数据的最佳数据是在componentDidMount</p><pre><code>const promise=axios.get(url)//返回一个promise...一个装载异步操作的对象---异步操作是计划在将来完成的操作创建promise后它立即进入pending状态--执行成功的resolved状态(success)/执行失败的refused状态(failure)//promise中有response获取response可以调用promise.then()可以得到异步操作的返回值可以使用JS中的await关键字const response=await promise得到异步操作的返回值(返回的是response对象)**只要用到await关键字，函数前需要加async修饰**</code></pre><h4 id="Creating-Data"><a href="#Creating-Data" class="headerlink" title="Creating Data"></a>Creating Data</h4><p>创建一个对象并将它传给后端</p><pre><code>//const obj={}const promise=axios.post(url,obj);//在创建数据时，要在request的请求体中包含数据内容,返回一个promise然后得到response//就是服务器返回更新的数据const response=await promise;//可以直接const {data:post}=await axios.post(url,obj);//返回值析构出data并重命名为post//更新const posts=[post,...this.state.posts];this.setState({posts});</code></pre><h4 id="Updating-Data"><a href="#Updating-Data" class="headerlink" title="Updating Data"></a>Updating Data</h4><p>axios更新方法有两个分别是</p><ul><li><p>push:更新所有的属性 </p><pre><code>post.title=&quot;UPDATED&quot;;const {data}=await axios.put(url+&apos;/&apos;+post.id,post);//更新一个特定的，所以需要在url中添加特定的id,第二个参数是更新的内容,put方法传入整个对象  返回一个promise 使用await 获得response</code></pre></li><li><p>patch:更新一个或多个属性</p><pre><code>post.title=&quot;UPDATED&quot;;const {data}=awaitaxios.patch(url+&apos;/&apos;+post.id,{title:post.title});//更新一个特定的，所以需要在url中添加特定的id,第二个参数是更新的内容,patch方法传入更新的属性返回一个promise 使用await 获得response</code></pre></li></ul><p>之后更新视图类似creating data</p><h4 id="Deleting-Data"><a href="#Deleting-Data" class="headerlink" title="Deleting Data"></a>Deleting Data</h4><pre><code>await axios.delete(url+&apos;/&apos;+post.id,post)const posts=this.state.posts.filter(p=&gt;p.id!==post.id)//出来删除的idthis.setState({posts})//更新</code></pre><h4 id="Axios拦截器"><a href="#Axios拦截器" class="headerlink" title="Axios拦截器"></a>Axios拦截器</h4><blockquote><p>axios.interceptors.response.use(null,error=&gt;{ </p><p>return Promise.reject(error);</p><p>})//第一个参数是成功执行，第二个参数是失败时执行,为了catch块得到控制权，返回一个拒绝promise</p></blockquote><h5 id="sentry-io-记录错误日志-ch8-15"><a href="#sentry-io-记录错误日志-ch8-15" class="headerlink" title="sentry.io:记录错误日志 ch8-15"></a>sentry.io:记录错误日志 ch8-15</h5><hr><h3 id="认证和授权"><a href="#认证和授权" class="headerlink" title="认证和授权"></a>认证和授权</h3><h4 id="JSON-Web-Tokens-JSON网络令牌"><a href="#JSON-Web-Tokens-JSON网络令牌" class="headerlink" title="JSON Web Tokens JSON网络令牌"></a>JSON Web Tokens JSON网络令牌</h4><p><strong>保存jwt(JSON网络令牌)</strong><br>每一个浏览器都有一个小型的本地数据库：local database</p><blockquote><p>localStorage.setItem(key,value)//第一参数是键，第二参数的值-传入jwt</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i jwt-decode //解码库</span><br><span class="line">localStorage.getItem(key)//得到jwt，参数是键</span><br><span class="line">jwt-decode(jwt);</span><br></pre></td></tr></table></figure><blockquote><p>localStorage.removeItem(key)//删除JWT</p></blockquote><blockquote><p>jwt.io:introdution</p></blockquote><h4 id="Calling-Protected-APIs-请求受保护的终端API"><a href="#Calling-Protected-APIs-请求受保护的终端API" class="headerlink" title="Calling Protected APIs 请求受保护的终端API"></a>Calling Protected APIs 请求受保护的终端API</h4><h4 id="Showing-Hiding-Elements-根据用户权限展现和隐藏页面元素"><a href="#Showing-Hiding-Elements-根据用户权限展现和隐藏页面元素" class="headerlink" title="Showing/Hiding Elements 根据用户权限展现和隐藏页面元素"></a>Showing/Hiding Elements 根据用户权限展现和隐藏页面元素</h4><h4 id="Protecting-Routes-保护路由机制-用户不能在无权限的情况下访问特定网页"><a href="#Protecting-Routes-保护路由机制-用户不能在无权限的情况下访问特定网页" class="headerlink" title="Protecting Routes 保护路由机制 :用户不能在无权限的情况下访问特定网页"></a>Protecting Routes 保护路由机制 :用户不能在无权限的情况下访问特定网页</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React&quot;&gt;&lt;a href=&quot;#React&quot; class=&quot;headerlink&quot; title=&quot;React&quot;&gt;&lt;/a&gt;React&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;学习React的一些笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;S
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Raspberrypi</title>
    <link href="http://wsmiley.github.io/2019/07/19/Raspberrypi/"/>
    <id>http://wsmiley.github.io/2019/07/19/Raspberrypi/</id>
    <published>2019-07-19T06:10:39.000Z</published>
    <updated>2019-07-19T07:00:45.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Raspberry"><a href="#Raspberry" class="headerlink" title="Raspberry"></a>Raspberry</h1><blockquote><p>不久前买个一个Raspberry,记录一些Raspberry的基本配置</p></blockquote><hr><h2 id="无屏幕-boot配置wifi"><a href="#无屏幕-boot配置wifi" class="headerlink" title="无屏幕/boot配置wifi"></a>无屏幕/boot配置wifi</h2><p>新建 wpa_supplicant.conf 文件，按下面格式保存</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">country=CN</span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1 </span><br><span class="line">network=&#123;</span><br><span class="line">ssid=&quot;WiFi-A&quot; #ssid:网络的ssid</span><br><span class="line">psk=&quot;12345678&quot; #psk:密码</span><br><span class="line">key_mgmt=WPA-PSK </span><br><span class="line">priority=1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><blockquote><p>sudo vim /etc/apt/sources.list.d/raspi.list<br><br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/raspberrypi/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/raspberrypi/</a> stretch main ui</p></blockquote><blockquote><p>sudo vim /etc/apt/sources.list</p></blockquote><blockquote><p>deb <a href="http://mirrors.aliyun.com/raspbian/raspbian/" target="_blank" rel="noopener">http://mirrors.aliyun.com/raspbian/raspbian/</a> stretch main contrib non-free rpi<br><br>deb <a href="https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/</a> stretch main contrib non-free rpi</p></blockquote><blockquote><p>sudo apt-get update</p></blockquote><blockquote><p>sudo apt-get upgrade</p></blockquote><hr><h2 id="vsftpd搭载FPT服务器"><a href="#vsftpd搭载FPT服务器" class="headerlink" title="vsftpd搭载FPT服务器"></a>vsftpd搭载FPT服务器</h2><p>安装vsftpd</p><blockquote><p>sudo apt-get install vsftpd</p></blockquote><p>开启FTP服务</p><blockquote><p>sudo service vsftpd start</p></blockquote><p>修改vsftpd配置文件</p><blockquote><p>sudo vim /etc/vsftpd.conf</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">anonymous_enable=YES   #匿名用户使能，允许匿名用户访问</span><br><span class="line">anon_root=/home/pi/ftpServer  #服务器的共享目录，需要自己创建</span><br><span class="line">no_anon_password=YES   # 匿名用户登录不需要密码</span><br><span class="line">write_enable=YES   #允许匿名用户进行写操作</span><br><span class="line">anon_upload_enable=YES   #允许匿名用户上传</span><br><span class="line">anon_mkdir_write_enable=YES   #允许匿名用户创建目录</span><br></pre></td></tr></table></figure><p>重启vsftpd服务</p><blockquote><p>sudo service vsftpd restart</p></blockquote><p>加入开机启动中：</p><blockquote><p>sudo vim /etc/rc.local<br>添加/etc/init.d/vsftpd restart</p></blockquote><hr><h2 id="Samba共享"><a href="#Samba共享" class="headerlink" title="Samba共享"></a>Samba共享</h2><p>安装samba所需软件</p><blockquote><p>sudo apt-get install samba samba-common-bin</p></blockquote><blockquote><p>sudo vim /etc/samba/smb.conf</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在末尾加入如下内容</span><br><span class="line"># 分享名称</span><br><span class="line">[MyNAS]</span><br><span class="line">    # 说明信息</span><br><span class="line">    comment = NAS Storage</span><br><span class="line">    # 可以访问的用户</span><br><span class="line">    valid users = pi,root</span><br><span class="line">    # 共享文件的路径,raspberry pi 会自动将连接到其上的外接存储设备挂载到/media/pi/目录下。</span><br><span class="line">    path = /home/pi/</span><br><span class="line">    # 可被其他人看到资源名称（非内容）</span><br><span class="line">    browseable = yes</span><br><span class="line">    # 可写</span><br><span class="line">    writable = yes</span><br><span class="line">    # 新建文件的权限为 664</span><br><span class="line">    create mask = 0664</span><br><span class="line">    # 新建目录的权限为 775</span><br><span class="line">    directory mask = 0775</span><br></pre></td></tr></table></figure><h3 id="测试配置文件是否有错误，根据提示做相应修改"><a href="#测试配置文件是否有错误，根据提示做相应修改" class="headerlink" title="测试配置文件是否有错误，根据提示做相应修改"></a>测试配置文件是否有错误，根据提示做相应修改</h3><blockquote><p>testparm</p></blockquote><p><strong>添加登陆账户并创建密码，必须是 linux 已存在的用户</strong></p><blockquote><p>sudo smbpasswd -a pi</p></blockquote><p><strong>重启 samba 服务</strong></p><blockquote></blockquote><p>sudo /etc/init.d/samba restart</p><hr><h2 id="内网穿透——公网ssh访问树莓派——frp-VPS"><a href="#内网穿透——公网ssh访问树莓派——frp-VPS" class="headerlink" title="内网穿透——公网ssh访问树莓派——frp+VPS"></a>内网穿透——公网ssh访问树莓派——frp+VPS</h2><p>参考文档：<a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">https://github.com/fatedier/frp</a></p><h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><p>登入VPS</p><blockquote><p>sudo apt-get update #更新源 </p></blockquote><blockquote><p>sudo wget <a href="https://github.com/fatedier/frp/releases/download/v0.25.1/frp_0.25.1_linux_amd64.tar.gz" target="_blank" rel="noopener">https://github.com/fatedier/frp/releases/download/v0.25.1/frp_0.25.1_linux_amd64.tar.gz</a></p></blockquote><blockquote><p>tar -xzvf frp_0.25.1_linux_amd64.tar.gz #解压</p></blockquote><blockquote><p>cd frp_0.25.1_linux_amd64</p></blockquote><p>修改frps.ini</p><blockquote><p>#frps.ini<br>[common]<br>bind_port = 7000</p></blockquote><p>开始frps</p><blockquote><p>./frps -c ./frps.ini</p></blockquote><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>登入raspberry</p><blockquote><p>sudo apt-get update #更新源</p></blockquote><blockquote><p>sudo wget <a href="https://github.com/fatedier/frp/releases/download/v0.25.1/frp_0.25.1_linux_arm.tar.gz" target="_blank" rel="noopener">https://github.com/fatedier/frp/releases/download/v0.25.1/frp_0.25.1_linux_arm.tar.gz</a></p></blockquote><blockquote><p>tar -xzvf frp_0.25.1_linux_amd.tar.gz #解压</p></blockquote><blockquote><p>cd frp_0.25.1_linux_amd</p></blockquote><p>修改frpc.ini，server_addr是你的frps的服务器IP：</p><p>注意vps端口需要在安全组中手动开启，否则ssh将connect refuse</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#frpc.ini </span><br><span class="line">[common] </span><br><span class="line">server_addr = xxxx</span><br><span class="line">server_port = 7000</span><br><span class="line">[ssh] </span><br><span class="line">type = tcp</span><br><span class="line"> local_ip = 127.0.0.1</span><br><span class="line"> local_port = 22</span><br><span class="line"> remote_port = 6000</span><br></pre></td></tr></table></figure><p>frpc开始</p><blockquote><p>./frpc -c ./frpc.ini</p></blockquote><p>从外网ssh </p><blockquote><p>ssh -oPort=6000 <a href="mailto:pi@x.x.x.x" target="_blank" rel="noopener">pi@x.x.x.x</a></p></blockquote><h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><h4 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h4><p>首先获取root权限，进入树莓派的systemd目录</p><blockquote><p>cd /lib/systemd/system</p></blockquote><p>新建文件</p><blockquote><p>touch frpc.service</p></blockquote><blockquote><p>vim frpc.service</p></blockquote><p>添加</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=frpc daemon</span><br><span class="line">After=network.target</span><br><span class="line">[Service]</span><br><span class="line">User=root</span><br><span class="line">Type=simple</span><br><span class="line">ExecStartPre=/bin/sleep 10</span><br><span class="line">ExecStart=frpc文件夹路径/frpc -c frpc文件夹路径/frpc.ini</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>最后使用systemctl将frpc.service启动，同时设置frpc开机自启：</p><blockquote><p>systemctl start frpc<br>systemctl enable  frpc</p></blockquote><h4 id="服务器端-1"><a href="#服务器端-1" class="headerlink" title="服务器端"></a>服务器端</h4><blockquote><p>vim /etc/systemd/system/frps.service</p></blockquote><blockquote><p>[Unit]<br><br>Description=frps daemon<br><br>After=syslog.target network.target<br><br>Wants=network.target<br><br>[Service]<br><br>Type=simple<br><br>ExecStart=frp文件路径/frps -c fpr文件路径/frps_my.ini<br><br>Restart= always<br><br>RestartSec=1min<br><br>[Install]<br><br>WantedBy=multi-user.target<br></p></blockquote><p>启动并设为开机自启。</p><blockquote><p>systemctl start frps //启动<br><br>systemctl status frps //状态查询<br><br>systemctl enable frps //开机启动<br></p></blockquote><blockquote><p>ssh -oPort=6000 <a href="mailto:test@x.x.x.x" target="_blank" rel="noopener">test@x.x.x.x</a></p></blockquote><hr><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>脚本一件安装</p><blockquote><p>curl -sSL <a href="https://get.docker.com" target="_blank" rel="noopener">https://get.docker.com</a> | sh</p></blockquote><p>下载.deb文件</p><blockquote><p><a href="https://apt.dockerproject.org/repo/pool/testing/d/docker-engine/" target="_blank" rel="noopener">https://apt.dockerproject.org/repo/pool/testing/d/docker-engine/</a></p></blockquote><blockquote><p>sudo dpkg -i /path/to/package.deb</p></blockquote><p>docker更换国内源</p><blockquote><p>sudo vim /etc/docker/daemon.json #文件不存在则会创建</p><pre><code>{ &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]}</code></pre></blockquote><p>重启docker并常驻服务</p><blockquote><pre><code>sudo systemctl restart docker.service sudo systemctl enable docker.service</code></pre></blockquote><p>安装docker图形化UI</p><blockquote><p>sudo docker pull portainer/portainer</p></blockquote><p>输入命令创建ui容器</p><blockquote><p>$ sudo docker run -d -p 9000:9000 –name portainer –restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Raspberry&quot;&gt;&lt;a href=&quot;#Raspberry&quot; class=&quot;headerlink&quot; title=&quot;Raspberry&quot;&gt;&lt;/a&gt;Raspberry&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;不久前买个一个Raspberry,记录一些Raspberr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nginx+hls+rtmp推流</title>
    <link href="http://wsmiley.github.io/2019/07/19/Nginx-hls-rtmp%E6%8E%A8%E6%B5%81/"/>
    <id>http://wsmiley.github.io/2019/07/19/Nginx-hls-rtmp推流/</id>
    <published>2019-07-19T05:42:25.000Z</published>
    <updated>2019-07-19T05:43:16.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rpi-Ubuntu-搭载视频推流服务器"><a href="#Rpi-Ubuntu-搭载视频推流服务器" class="headerlink" title="Rpi+Ubuntu 搭载视频推流服务器"></a>Rpi+Ubuntu 搭载视频推流服务器</h1><hr><blockquote><p><strong>源码编译nginx+hls+rtmp，nginx配置文件，推流方式以及播放方法</strong></p></blockquote><hr><h3 id="编译Nginx-会有很多error…"><a href="#编译Nginx-会有很多error…" class="headerlink" title="编译Nginx(会有很多error…)"></a>编译Nginx(会有很多error…)</h3><p>建立源码编译目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir nginx_src</span><br><span class="line">cd nginx_src</span><br></pre></td></tr></table></figure><p>使用Git下载源码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#nginx源码</span><br><span class="line">//wget https://nginx.org/download/nginx-1.13.4.tar.gz</span><br><span class="line">//解压</span><br><span class="line">#nginx的rtmp模块源码</span><br><span class="line">sudo git clone https://github.com/arut/nginx-rtmp-module.git</span><br><span class="line">##nginx的依赖pcre源码</span><br><span class="line">sudo wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.39.tar.gz</span><br><span class="line">tar -xzvf pcre-8.39.tar.gz</span><br><span class="line">cd nginx</span><br><span class="line">git checkout release-1.9.9</span><br><span class="line">#安装编译依赖</span><br><span class="line">sudo apt-get install build-essential libpcre3 libpcre3-dev libssl-dev</span><br></pre></td></tr></table></figure><p>准备编译安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ./configure --prefix=/usr/local/nginx \</span><br><span class="line">        --with-pcre=../pcre-8.39 \</span><br><span class="line">                --with-http_ssl_module \</span><br><span class="line">                --with-http_v2_module \</span><br><span class="line">                --with-http_flv_module \</span><br><span class="line">                --with-http_mp4_module \</span><br><span class="line">                --add-module=./nginx-rtmp-module/</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>启动nginx服务器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p>Nginx配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/local/nginx/conf/nginx.conf</span><br><span class="line">sudo vim /usr/local/nginx/conf/nginx.conf.default</span><br><span class="line">#添加上</span><br><span class="line">rtmp &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1935;  #监听的端口</span><br><span class="line">        chunk_size 4096;</span><br><span class="line">        application hls &#123;  #rtmp推流请求路径: rtmp://ipaddress:1935/hls</span><br><span class="line">            live on;</span><br><span class="line">            record off;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启Nginx</p><blockquote><p>sudo service nginx restart</p></blockquote><p>安装ffmpeg</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-add-repository ppa:jon-severinsson/ffmpeg</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ffmpeg</span><br></pre></td></tr></table></figure><p>推流命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -r 30 -pix_fmt yuv420p -f v4l2 -video_size vga -i /dev/video0 -pix_fmt yuv420p -f flv -b:v 500k rtmp://127.0.0.1:1935/hls</span><br><span class="line"></span><br><span class="line">ffmpeg -r 30 -pix_fmt yuv420p -f v4l2 -video_size vga -i /dev/video0 -pix_fmt yuv420p -f flv -b:v 500k -tune zerolantency -preset fast rtmp://127.0.0.1:1935/hls</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Rpi-Ubuntu-搭载视频推流服务器&quot;&gt;&lt;a href=&quot;#Rpi-Ubuntu-搭载视频推流服务器&quot; class=&quot;headerlink&quot; title=&quot;Rpi+Ubuntu 搭载视频推流服务器&quot;&gt;&lt;/a&gt;Rpi+Ubuntu 搭载视频推流服务器&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理解PID</title>
    <link href="http://wsmiley.github.io/2019/07/19/%E7%90%86%E8%A7%A3PID/"/>
    <id>http://wsmiley.github.io/2019/07/19/理解PID/</id>
    <published>2019-07-19T02:22:56.000Z</published>
    <updated>2019-07-19T05:40:41.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h1><ul><li>比例控制</li><li>积分控制</li><li>微分控制</li></ul><h3 id="历史偏差，当前偏差，最近偏差"><a href="#历史偏差，当前偏差，最近偏差" class="headerlink" title="历史偏差，当前偏差，最近偏差"></a><strong>历史偏差，当前偏差，最近偏差</strong></h3><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="位式控制"><a href="#位式控制" class="headerlink" title="位式控制"></a>位式控制</h3><p>设定值Sv与当前值Xn的差值En，En去控制开关(高、低电平)，因为具有惯性，会导致偏差过大。</p><hr><h2 id="比例控制-当前偏差值"><a href="#比例控制-当前偏差值" class="headerlink" title="比例控制(当前偏差值)"></a>比例控制(当前偏差值)</h2><p>根据当前偏差比例大小输出控制信号</p><p><strong>缺点:当前值和设定值相等时,会对控制部件失去控制,即有偏差控制</strong></p><p>1、Sv设定值，X1,X2,…,Xn从开机以来传感器取样值(离散值)</p><p>2、根据数据得到信息 </p><ul><li>当前偏差值En=Sv-Xn，Out=Kp*En(比例控制),Out数值控制脉冲的宽度(pwm),En说明当前情况</li></ul><p>弥补缺陷</p><ul><li>POut=Kp*En+POut0,当En为0时,输出一个POut0(尽量取小)</li></ul><h2 id="积分控制-历史偏差值"><a href="#积分控制-历史偏差值" class="headerlink" title="积分控制(历史偏差值)"></a>积分控制(历史偏差值)</h2><p>历史偏差序列:E1，E2，…，En</p><blockquote><p><strong>代数和Sn=E1+E2+E3+…+En,Sn说明的是历史上的情况(Sn不可能无穷大)</strong></p></blockquote><ul><li><p>Sn&gt;0:过去大部分时间未达标</p></li><li><p>Sn=0:</p></li><li><p>Sn&lt;0:过去大部分时间超标</p></li></ul><blockquote><p><strong>IOut=Kp*Sn(积分控制)+IOut0，”IOut0当Sn=0时,给出一个适当的控制信号,避免失去控制</strong></p></blockquote><p>缺点:当历史上总体是好的,即Sn=0时，会对控制部件失去控制</p><h2 id="微分控制-最近偏差值"><a href="#微分控制-最近偏差值" class="headerlink" title="微分控制(最近偏差值)"></a>微分控制(最近偏差值)</h2><p><strong>考察前一个时刻和这一个时刻两个时间点的偏差值,即最近两次偏差相减。(预见性控制,不能单独控制)</strong></p><p><strong>不能单独控制的原因是:微分控制是只考察偏差有没有变化趋势,不考察偏差存不存在</strong></p><p>Dn:两次变化偏差之差。即偏差的一种变化趋势(理解为斜率)</p><blockquote><p>Dn=En-En-1</p><ul><li>Dn&gt;0:偏差增大趋势</li><li>Dn=0:无偏差</li><li>Dn&lt;0:偏差减小趋势</li></ul></blockquote><blockquote><p>DOut=Kp*Dn+Dout0</p></blockquote><p>Kp系数乘以Dn去夸大Dn(斜率),提高控制灵敏度,夸大的目的是为了更好的抑制将来的变化。DOut0:维持静态误差</p><hr><h3 id="系数的作用"><a href="#系数的作用" class="headerlink" title="系数的作用"></a>系数的作用</h3><blockquote><p>1.比例系数Kp的作用是加快系统的响应速度，提高系统的调节精度。Kp越大，系统的响应速度越快，系统的调节精度越高，但是容易产生超调，甚至会使系统不稳定。Kp取值过小，则会降低调节精度，使响应速度缓慢，从而延长调节时间，是系统静态、动态特性变差；</p></blockquote><blockquote><p>2.积分作用系数Ki的作用是消除系统的稳态误差。Ki越大，系统的静态误差消除的越快，但是Ki过大，在响应过程的初期会产生积分饱和的现象，从而引起响应过程的较大超调。若Ki过小，将使系统静态误差难以消除，影响系统的调节精度；</p></blockquote><blockquote><p>3.微分系数Kd的作用是改善系统的动态特性，其作用主要是在响应过程中抑制偏差向任何方向的变化，对偏差变化进行提前预报。但是kd过大，会使响应过程提前制动，从而延长调节时间，而且会降低系统的抗干扰性。</p></blockquote><hr><h1 id="位置型PID实现"><a href="#位置型PID实现" class="headerlink" title="位置型PID实现"></a>位置型PID实现</h1><h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">pid</span>&#123;</span></span><br><span class="line">   <span class="keyword">float</span> SetSpeed;             <span class="comment">//设定值</span></span><br><span class="line">   <span class="keyword">float</span> ActualSpeed;          <span class="comment">//当前值</span></span><br><span class="line">   <span class="keyword">float</span> err;                  <span class="comment">//偏差值</span></span><br><span class="line">   <span class="keyword">float</span> err_last;             <span class="comment">//上一个偏差值</span></span><br><span class="line">   <span class="keyword">float</span> Kp,Ki,Kd;             <span class="comment">//比例，积分、微分系数</span></span><br><span class="line">   <span class="keyword">float</span> err_sum;             <span class="comment">//偏差累加值</span></span><br><span class="line">   <span class="keyword">float</span> out_sum;             <span class="comment">//输出值</span></span><br><span class="line">&#125;pid;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PID_Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"PID_Init begin\n"</span>);</span><br><span class="line">  pid.SetSpeed=<span class="number">0.0</span>;</span><br><span class="line">  pid.ActualSpeed=<span class="number">0.0</span>;</span><br><span class="line">  pid.err=<span class="number">0.0</span>;</span><br><span class="line">  pid.err_last=<span class="number">0.0</span>;</span><br><span class="line">  pid.out_sum=<span class="number">0.0</span>;</span><br><span class="line">  <span class="comment">//Kp,Ki,Kd设定值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"PID_Init end\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写控制算法"><a href="#编写控制算法" class="headerlink" title="编写控制算法"></a>编写控制算法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">PID_Realize</span><span class="params">(<span class="keyword">float</span> speed)</span></span>&#123;</span><br><span class="line">  pid.SetSpeed=speed;</span><br><span class="line">  pid.err=pid.SetSpeed- pid.ActualSpeed;</span><br><span class="line">  pid.err_sum+=pid.err;</span><br><span class="line">  pid.out_sum=pid.Kp*pid.err+pid.Ki*pid.err_sum+pid.Kd*(pid.err-pid.err_last);</span><br><span class="line">  pid.err_last=pid.err;</span><br><span class="line">  pid.ActualSpeed=pid.out_sum*<span class="number">1.0</span>;</span><br><span class="line">  <span class="keyword">return</span> pid.ActualSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="增量型PID实现"><a href="#增量型PID实现" class="headerlink" title="增量型PID实现"></a>增量型PID实现</h1><p>(本次控制量和上次控制量的差值)</p><p><img src="//wsmiley.github.io/2019/07/19/理解PID/%E5%A2%9E%E9%87%8F%E5%BC%8F.png" alt="增量PID"></p><h2 id="定义结构体-1"><a href="#定义结构体-1" class="headerlink" title="定义结构体"></a>定义结构体</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">pid</span>&#123;</span></span><br><span class="line">   <span class="keyword">float</span> SetSpeed;             <span class="comment">//设定值</span></span><br><span class="line">   <span class="keyword">float</span> ActualSpeed;          <span class="comment">//当前值</span></span><br><span class="line">   <span class="keyword">float</span> err;                  <span class="comment">//偏差值</span></span><br><span class="line">   <span class="keyword">float</span> err_last;             <span class="comment">//上一个偏差值</span></span><br><span class="line">   flaot err_second;           <span class="comment">//上上一个偏差值</span></span><br><span class="line">   <span class="keyword">float</span> Kp,Ki,Kd;             <span class="comment">//比例，积分、微分系数</span></span><br><span class="line">&#125;pid;</span><br></pre></td></tr></table></figure><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PID_Init</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"PID_Init begin\n"</span>);</span><br><span class="line">  pid.SetSpeed=<span class="number">0.0</span>;</span><br><span class="line">  pid.ActualSpeed=<span class="number">0.0</span>;</span><br><span class="line">  pid.err=<span class="number">0.0</span>;</span><br><span class="line">  pid.err_last=<span class="number">0.0</span>;</span><br><span class="line">  pid.err_second=<span class="number">0.0</span>;</span><br><span class="line">  <span class="comment">//Kp,Ki,Kd设定值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"PID_Init end\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="控制算法"><a href="#控制算法" class="headerlink" title="控制算法"></a>控制算法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">PID_Realize</span><span class="params">(<span class="keyword">float</span> speed)</span></span>&#123;</span><br><span class="line">  pid.SetSpeed=speed;</span><br><span class="line">  pid.err=pid.SetSpeed-pid.ActualSpeed;</span><br><span class="line">  <span class="keyword">float</span> incrementSpeed</span><br><span class="line">  incrementSpeed=pid.Kp*(pid.err-pid.err_last)+pid.Ki*pid.err+pid.Kd*(pid.err<span class="number">-2</span>*pid.err_last+pid.err_second)</span><br><span class="line">  pid.ActualSpeed+=incrementSpeed;</span><br><span class="line">  pid.err_second=pid_err_last;</span><br><span class="line">  pid.err_last=pid.err;</span><br><span class="line">  <span class="keyword">return</span> pid.ActualSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="积分分离PID实现"><a href="#积分分离PID实现" class="headerlink" title="积分分离PID实现"></a>积分分离PID实现</h1><p>引入积分的目的:为了消除静差,提高控制精度。但是在启动、结束/大幅度增减设定时,短时间内系统输出有很大的偏差，会造成PID运算的积分累积。</p><p>积分分离思路:当被控量与设定值偏差较大时,取消积分作用。当被控量接近定值时,引入积分控制，消除静差,提高控制精度。</p><h2 id="控制算法-1"><a href="#控制算法-1" class="headerlink" title="控制算法"></a>控制算法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(pid.err)&gt;<span class="number">200</span>)&#123;</span><br><span class="line">  index=<span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  index=<span class="number">1</span>;</span><br><span class="line">  pid.err_sum+=pid.err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pid.out_sum=pid.Kp*pid.err+index*pid.Ki*pid.pid.err_sum+pid.Kd*(pid.err-pid.err_last);</span><br></pre></td></tr></table></figure><h1 id="变积分的PID实现"><a href="#变积分的PID实现" class="headerlink" title="变积分的PID实现"></a>变积分的PID实现</h1><p><strong>系统对于积分项的要求是，系统偏差大时，积分作用应该减弱甚至是全无，而在偏差小时，则应该加强</strong></p><blockquote><p><strong>思想:变积分PID的基本思想是设法改变积分项的累加速度，使其与偏差大小相对应：偏差越大，积分越慢; 偏差越小，积分越快。</strong></p></blockquote><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>积分系数前加一个比例值index</p><p>当abs(err)&lt;180时，index=1;<br><br>当180&lt; abs(err) &lt;200时，index=(200-abs(err))/20;<br><br>当abs(err)&gt;200时,index=0；</p><p>最终的比例环节的比例系数值Ki*index</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float PID_Realize(float speed)&#123;</span><br><span class="line">  float index;</span><br><span class="line">  pid.SetSpeed=speed;</span><br><span class="line">  pid.err=pid.SetSpeed-pid.ActualSpeed;</span><br><span class="line">  </span><br><span class="line">  if(abs(pid.err)&gt;200)&#123;</span><br><span class="line">    index=0.0;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    if(abs(err)&lt;180)&#123;</span><br><span class="line">      index=1.0;</span><br><span class="line">      pid.err_sum+=pid.err;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      index=(200-abs(err))/20;</span><br><span class="line">      pid.err_sum+pid.pid.err;</span><br><span class="line">    &#125;</span><br><span class="line">  pid.out_sum=pid.Kp*pid.err+index*pid_Ki*pid.err_sum+pid.Kd*(pid.err-pid.err_last);</span><br><span class="line">  pid.err_last=pid.err;</span><br><span class="line">  pid.ActualSpeed=pid.out.sum*1.0;</span><br><span class="line">  return pid.ActualSpeed;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PID&quot;&gt;&lt;a href=&quot;#PID&quot; class=&quot;headerlink&quot; title=&quot;PID&quot;&gt;&lt;/a&gt;PID&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;比例控制&lt;/li&gt;
&lt;li&gt;积分控制&lt;/li&gt;
&lt;li&gt;微分控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;历史偏差，当前偏
      
    
    </summary>
    
    
      <category term="PID" scheme="http://wsmiley.github.io/tags/PID/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-Github构建个人博客</title>
    <link href="http://wsmiley.github.io/2019/07/18/Hexo-Github%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://wsmiley.github.io/2019/07/18/Hexo-Github构建个人博客/</id>
    <published>2019-07-18T12:30:24.000Z</published>
    <updated>2019-07-19T05:07:54.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p><hr><h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo?"></a>什么是Hexo?</h2><blockquote><p><strong>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</strong></p></blockquote><hr><h3 id="Hexo-Github发文原理"><a href="#Hexo-Github发文原理" class="headerlink" title="Hexo+Github发文原理"></a>Hexo+Github发文原理</h3><h2 id><a href="#" class="headerlink" title></a><img src="//wsmiley.github.io/2019/07/18/Hexo-Github构建个人博客/Hexo%E5%8F%91%E6%96%87%E5%8E%9F%E7%90%86.png" alt="Hexo发文原理"></h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a><strong>环境搭建</strong></h3><ul><li>Node.js       <a href="https://nodejs.org/" target="_blank" rel="noopener">https://nodejs.org/</a></li><li>Git         <a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></li><li>Github账号  <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></li></ul><h4 id="Github创建仓库"><a href="#Github创建仓库" class="headerlink" title="Github创建仓库"></a>Github创建仓库</h4><p>建立与用户名对应的仓库，仓库名必须为[username.github.io]。</p><p><img src="//wsmiley.github.io/2019/07/18/Hexo-Github构建个人博客/Github%E4%BB%93%E5%BA%93.png" alt="Github仓库"></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>在本地创建一个文件夹。</p><p>进入命令行</p><blockquote><p>npm install -g hexo-cli</p></blockquote><p>安装完毕后 </p><blockquote><p>hexo init &lt; folder &gt;</p></blockquote><p>&lt; folder &gt;是名称</p><p>新建完成后</p><p>指定文件夹的目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p><img src="//wsmiley.github.io/2019/07/18/Hexo-Github构建个人博客/hexo%E5%91%BD%E4%BB%A4.png" alt="hexo命令"></p><h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><p>网站的 配置 信息，您可以在此配置大部分的参数。</p><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><p>应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">package.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"hexo-site"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"hexo"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">""</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"hexo"</span>: <span class="string">"^3.8.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-archive"</span>: <span class="string">"^0.1.5"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-category"</span>: <span class="string">"^0.1.3"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-index"</span>: <span class="string">"^0.2.1"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-tag"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-ejs"</span>: <span class="string">"^0.3.1"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-stylus"</span>: <span class="string">"^0.3.3"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-marked"</span>: <span class="string">"^0.3.2"</span>,</span><br><span class="line">    <span class="attr">"hexo-server"</span>: <span class="string">"^0.3.3"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h4><p>模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p><p>Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p><h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><p>资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p><h4 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h4><p>主题 文件夹。Hexo 会根据主题来生成静态页面。</p><blockquote><p>在hexo init目录下<br><br>$ hexo server     //在本地起一个server</p></blockquote><p><img src="//wsmiley.github.io/2019/07/18/Hexo-Github构建个人博客/hexoserver%E5%91%BD%E4%BB%A4.png" alt="hexoserver命令"></p><p>在chrome输入localhost:4000,可看到配置好的Hexo页面</p><h2 id="将Hexo与Github联接起来"><a href="#将Hexo与Github联接起来" class="headerlink" title="将Hexo与Github联接起来"></a>将Hexo与Github联接起来</h2><ul><li>配置Git</li><li>配置Deployment</li></ul><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>在命令行下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br><span class="line">$ git config --global user.name &quot;your username&quot;</span><br><span class="line">$ git config --global user.email youremail@example.com</span><br></pre></td></tr></table></figure><p>在用户目录下查找.ssh文件夹,里面有id_rsa(私钥),id_rsa.pub(公钥)两个文件。</p><p>登入Githu,打开“Account settings”，“SSH Keys”页面，然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容，即可。</p><blockquote><p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p></blockquote><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>在_config.yml文件中,找到Deploy,修改格式如下。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">     type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">     repo:</span> <span class="attr">https://github.com/WSmiley/WSmiley.github.io.git</span></span><br><span class="line"><span class="attr">     branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>成功后Github仓库<br><img src="//wsmiley.github.io/2019/07/18/Hexo-Github构建个人博客/Github%E9%A1%B5%E9%9D%A2.png" alt="Github页面"></p><blockquote><p>浏览器输入<a href="http://WSmiley.github.io/">http://WSmiley.github.io/</a></p></blockquote><h2 id="Hexo主题"><a href="#Hexo主题" class="headerlink" title="Hexo主题"></a>Hexo主题</h2><p>执行如下命令</p><blockquote><p>npm install –save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</p></blockquote><p>在_config.yml文件中,找到Scheme</p><blockquote><p>theme: melody # 将主题设置成melody</p></blockquote><p>melody：<a href="https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/" target="_blank" rel="noopener">https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/</a></p><p>ocean：<a href="https://github.com/zhwangart/hexo-theme-ocean" target="_blank" rel="noopener">https://github.com/zhwangart/hexo-theme-ocean</a></p><p><strong>需要git clone相应的项目</strong></p><p>验证设置主题,执行命令</p><blockquote><p>hexo server</p></blockquote><p>在chrome输入 localhost:4000</p><hr><h2 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h2><p>每次部署前建议操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line"></span><br><span class="line">$ hexo generate</span><br><span class="line"></span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>其他命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new&quot;postName&quot; #新建文章</span><br><span class="line">hexo new page&quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</span><br><span class="line">hexo deploy #将.deploy目录部署到GitHub</span><br><span class="line">hexo help # 查看帮助</span><br><span class="line">hexo version #查看Hexo的版本</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="如何在markdown加入图片"><a href="#如何在markdown加入图片" class="headerlink" title="如何在markdown加入图片"></a>如何在markdown加入图片</h3><p>_config.yml 里的post_asset_folder:这个选项设置为true</p><blockquote><p>post_asset_folder:true</p></blockquote><p>_config.yml 里修改URL避免github中图片引用路径出现问题</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">##If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; &gt;and root as &apos;/child/&apos;</span><br><span class="line">url: http://wsmiley.github.io</span><br><span class="line">root: /</span><br></pre></td></tr></table></figure><p>在你的hexo目录下执行</p><blockquote><p>npm install hexo-asset-image –save</p></blockquote><p>当你新建文章时,会出现同名文件夹</p><blockquote><p>hexo n “xxx”</p></blockquote><p>最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：</p><h5 id="你想输入的替代文字-xxxx-图片名-jpg"><a href="#你想输入的替代文字-xxxx-图片名-jpg" class="headerlink" title="![你想输入的替代文字] (xxxx/图片名.jpg)"></a>![你想输入的替代文字] (xxxx/图片名.jpg)</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo&quot;&gt;&lt;a href=&quot;#Hexo&quot; class=&quot;headerlink&quot; title=&quot;Hexo&quot;&gt;&lt;/a&gt;Hexo&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://wsmiley.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
