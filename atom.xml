<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Smiley</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wsmiley.github.io/"/>
  <updated>2019-07-19T03:00:29.932Z</updated>
  <id>http://wsmiley.github.io/</id>
  
  <author>
    <name>Smiley</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>理解PID</title>
    <link href="http://wsmiley.github.io/2019/07/19/%E7%90%86%E8%A7%A3PID/"/>
    <id>http://wsmiley.github.io/2019/07/19/理解PID/</id>
    <published>2019-07-19T02:22:56.000Z</published>
    <updated>2019-07-19T03:00:29.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h1><ul><li>比例控制</li><li>积分控制</li><li>微分控制</li></ul><h3 id="历史偏差，当前偏差，最近偏差"><a href="#历史偏差，当前偏差，最近偏差" class="headerlink" title="历史偏差，当前偏差，最近偏差"></a><strong>历史偏差，当前偏差，最近偏差</strong></h3><hr><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="位式控制"><a href="#位式控制" class="headerlink" title="位式控制"></a>位式控制</h3><p>设定值Sv与当前值Xn的差值En，En去控制开关(高、低电平)，因为具有惯性，会导致偏差过大。</p><hr><h2 id="比例控制-当前偏差值"><a href="#比例控制-当前偏差值" class="headerlink" title="比例控制(当前偏差值)"></a>比例控制(当前偏差值)</h2><p>根据当前偏差比例大小输出控制信号</p><p><strong>缺点:当前值和设定值相等时,会对控制部件失去控制,即有偏差控制</strong></p><p>1、Sv设定值，X1,X2,…,Xn从开机以来传感器取样值(离散值)</p><p>2、根据数据得到信息 </p><ul><li>当前偏差值En=Sv-Xn，Out=Kp*En(比例控制),Out数值控制脉冲的宽度(pwm),En说明当前情况</li></ul><p>弥补缺陷</p><ul><li>POut=Kp*En+POut0,当En为0时,输出一个POut0(尽量取小)</li></ul><h2 id="积分控制-历史偏差值"><a href="#积分控制-历史偏差值" class="headerlink" title="积分控制(历史偏差值)"></a>积分控制(历史偏差值)</h2><p>历史偏差序列:E1，E2，…，En</p><blockquote><p><strong>代数和Sn=E1+E2+E3+…+En,Sn说明的是历史上的情况(Sn不可能无穷大)</strong></p></blockquote><ul><li><p>Sn&gt;0:过去大部分时间未达标</p></li><li><p>Sn=0:</p></li><li><p>Sn&lt;0:过去大部分时间超标</p></li></ul><blockquote><p><strong>IOut=Kp*Sn(积分控制)+IOut0，”IOut0当Sn=0时,给出一个适当的控制信号,避免失去控制</strong></p></blockquote><p>缺点:当历史上总体是好的,即Sn=0时，会对控制部件失去控制</p><h2 id="微分控制-最近偏差值"><a href="#微分控制-最近偏差值" class="headerlink" title="微分控制(最近偏差值)"></a>微分控制(最近偏差值)</h2><p><strong>考察前一个时刻和这一个时刻两个时间点的偏差值,即最近两次偏差相减。(预见性控制,不能单独控制)</strong></p><p><strong>不能单独控制的原因是:微分控制是只考察偏差有没有变化趋势,不考察偏差存不存在</strong></p><p>Dn:两次变化偏差之差。即偏差的一种变化趋势(理解为斜率)</p><blockquote><p>Dn=En-En-1</p><ul><li>Dn&gt;0:偏差增大趋势</li><li>Dn=0:无偏差</li><li>Dn&lt;0:偏差减小趋势</li></ul></blockquote><blockquote><p>DOut=Kp*Dn+Dout0</p></blockquote><p>Kp系数乘以Dn去夸大Dn(斜率),提高控制灵敏度,夸大的目的是为了更好的抑制将来的变化。DOut0:维持静态误差</p><hr><h3 id="系数的作用"><a href="#系数的作用" class="headerlink" title="系数的作用"></a>系数的作用</h3><blockquote><p>1.比例系数Kp的作用是加快系统的响应速度，提高系统的调节精度。Kp越大，系统的响应速度越快，系统的调节精度越高，但是容易产生超调，甚至会使系统不稳定。Kp取值过小，则会降低调节精度，使响应速度缓慢，从而延长调节时间，是系统静态、动态特性变差；</p></blockquote><blockquote><p>2.积分作用系数Ki的作用是消除系统的稳态误差。Ki越大，系统的静态误差消除的越快，但是Ki过大，在响应过程的初期会产生积分饱和的现象，从而引起响应过程的较大超调。若Ki过小，将使系统静态误差难以消除，影响系统的调节精度；</p></blockquote><blockquote><p>3.微分系数Kd的作用是改善系统的动态特性，其作用主要是在响应过程中抑制偏差向任何方向的变化，对偏差变化进行提前预报。但是kd过大，会使响应过程提前制动，从而延长调节时间，而且会降低系统的抗干扰性。</p></blockquote><hr><h1 id="位置型PID实现"><a href="#位置型PID实现" class="headerlink" title="位置型PID实现"></a>位置型PID实现</h1><h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct _pid&#123;</span><br><span class="line">   float SetSpeed;             //设定值</span><br><span class="line">   float ActualSpeed;          //当前值</span><br><span class="line">   float err;                  //偏差值</span><br><span class="line">   float err_last;             //上一个偏差值</span><br><span class="line">   float Kp,Ki,Kd;             //比例，积分、微分系数</span><br><span class="line">   float err_sum;             //偏差累加值</span><br><span class="line">   float out_sum;             //输出值</span><br><span class="line">&#125;pid;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void PID_Init()&#123;</span><br><span class="line">  printf(&quot;PID_Init begin\n&quot;);</span><br><span class="line">  pid.SetSpeed=0.0;</span><br><span class="line">  pid.ActualSpeed=0.0;</span><br><span class="line">  pid.err=0.0;</span><br><span class="line">  pid.err_last=0.0;</span><br><span class="line">  pid.out_sum=0.0;</span><br><span class="line">  //Kp,Ki,Kd设定值</span><br><span class="line">  printf(&quot;PID_Init end\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写控制算法"><a href="#编写控制算法" class="headerlink" title="编写控制算法"></a>编写控制算法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float PID_Realize(float speed)&#123;</span><br><span class="line">  pid.SetSpeed=speed;</span><br><span class="line">  pid.err=pid.SetSpeed- pid.ActualSpeed;</span><br><span class="line">  pid.err_sum+=pid.err;</span><br><span class="line">  pid.out_sum=pid.Kp*pid.err+pid.Ki*pid.err_sum+pid.Kd*(pid.err-pid.err_last);</span><br><span class="line">  pid.err_last=pid.err;</span><br><span class="line">  pid.ActualSpeed=pid.out_sum*1.0;</span><br><span class="line">  return pid.ActualSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="增量型PID实现"><a href="#增量型PID实现" class="headerlink" title="增量型PID实现"></a>增量型PID实现</h1><p>(本次控制量和上次控制量的差值)</p><p><img src="//wsmiley.github.io/2019/07/19/理解PID/%E5%A2%9E%E9%87%8F%E5%BC%8F.png" alt="增量PID"></p><h2 id="定义结构体-1"><a href="#定义结构体-1" class="headerlink" title="定义结构体"></a>定义结构体</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct _pid&#123;</span><br><span class="line">   float SetSpeed;             //设定值</span><br><span class="line">   float ActualSpeed;          //当前值</span><br><span class="line">   float err;                  //偏差值</span><br><span class="line">   float err_last;             //上一个偏差值</span><br><span class="line">   flaot err_second;           //上上一个偏差值</span><br><span class="line">   float Kp,Ki,Kd;             //比例，积分、微分系数</span><br><span class="line">&#125;pid;</span><br></pre></td></tr></table></figure><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void PID_Init()&#123;&#125;</span><br><span class="line">  printf(&quot;PID_Init begin\n&quot;);</span><br><span class="line">  pid.SetSpeed=0.0;</span><br><span class="line">  pid.ActualSpeed=0.0;</span><br><span class="line">  pid.err=0.0;</span><br><span class="line">  pid.err_last=0.0;</span><br><span class="line">  pid.err_second=0.0;</span><br><span class="line">  //Kp,Ki,Kd设定值</span><br><span class="line">  printf(&quot;PID_Init end\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="控制算法"><a href="#控制算法" class="headerlink" title="控制算法"></a>控制算法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float PID_Realize(float speed)&#123;</span><br><span class="line">  pid.SetSpeed=speed;</span><br><span class="line">  pid.err=pid.SetSpeed-pid.ActualSpeed;</span><br><span class="line">  float incrementSpeed</span><br><span class="line">  incrementSpeed=pid.Kp*(pid.err-pid.err_last)+pid.Ki*pid.err+pid.Kd*(pid.err-2*pid.err_last+pid.err_second)</span><br><span class="line">  pid.ActualSpeed+=incrementSpeed;</span><br><span class="line">  pid.err_second=pid_err_last;</span><br><span class="line">  pid.err_last=pid.err;</span><br><span class="line">  return pid.ActualSpeed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="积分分离PID实现"><a href="#积分分离PID实现" class="headerlink" title="积分分离PID实现"></a>积分分离PID实现</h1><p>引入积分的目的:为了消除静差,提高控制精度。但是在启动、结束/大幅度增减设定时,短时间内系统输出有很大的偏差，会造成PID运算的积分累积。</p><p>积分分离思路:当被控量与设定值偏差较大时,取消积分作用。当被控量接近定值时,引入积分控制，消除静差,提高控制精度。</p><h2 id="控制算法-1"><a href="#控制算法-1" class="headerlink" title="控制算法"></a>控制算法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(abs(pid.err)&gt;200)&#123;</span><br><span class="line">  index=0;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  index=1;</span><br><span class="line">  pid.err_sum+=pid.err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pid.out_sum=pid.Kp*pid.err+index*pid.Ki*pid.pid.err_sum+pid.Kd*(pid.err-pid.err_last);</span><br></pre></td></tr></table></figure><h1 id="变积分的PID实现"><a href="#变积分的PID实现" class="headerlink" title="变积分的PID实现"></a>变积分的PID实现</h1><p><strong>系统对于积分项的要求是，系统偏差大时，积分作用应该减弱甚至是全无，而在偏差小时，则应该加强</strong></p><blockquote><p><strong>思想:变积分PID的基本思想是设法改变积分项的累加速度，使其与偏差大小相对应：偏差越大，积分越慢; 偏差越小，积分越快。</strong></p></blockquote><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>积分系数前加一个比例值index</p><p>当abs(err)&lt;180时，index=1;<br><br>当180&lt; abs(err) &lt;200时，index=(200-abs(err))/20;<br><br>当abs(err)&gt;200时,index=0；</p><p>最终的比例环节的比例系数值Ki*index</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float PID_Realize(float speed)&#123;</span><br><span class="line">  </span><br><span class="line">  float index;</span><br><span class="line"></span><br><span class="line">  pid.SetSpeed=speed;</span><br><span class="line">  pid.err=pid.SetSpeed-pid.ActualSpeed;</span><br><span class="line">  </span><br><span class="line">  if(abs(pid.err)&gt;200)&#123;</span><br><span class="line">    index=0.0;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    if(abs(err)&lt;180)&#123;</span><br><span class="line">      index=1.0;</span><br><span class="line">      pid.err_sum+=pid.err;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      index=(200-abs(err))/20;</span><br><span class="line">      pid.err_sum+pid.pid.err;</span><br><span class="line">    &#125;</span><br><span class="line">  pid.out_sum=pid.Kp*pid.err+index*pid_Ki*pid.err_sum+pid.Kd*(pid.err-pid.err_last);</span><br><span class="line">  pid.err_last=pid.err;</span><br><span class="line">  pid.ActualSpeed=pid.out.sum*1.0;</span><br><span class="line">  return pid.ActualSpeed;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PID&quot;&gt;&lt;a href=&quot;#PID&quot; class=&quot;headerlink&quot; title=&quot;PID&quot;&gt;&lt;/a&gt;PID&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;比例控制&lt;/li&gt;
&lt;li&gt;积分控制&lt;/li&gt;
&lt;li&gt;微分控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;历史偏差，当前偏
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo-Github构建个人博客</title>
    <link href="http://wsmiley.github.io/2019/07/18/Hexo-Github%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://wsmiley.github.io/2019/07/18/Hexo-Github构建个人博客/</id>
    <published>2019-07-18T12:30:24.000Z</published>
    <updated>2019-07-19T02:53:10.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p><hr><h2 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo?"></a>什么是Hexo?</h2><blockquote><p><strong>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</strong></p></blockquote><hr><h3 id="Hexo-Github发文原理"><a href="#Hexo-Github发文原理" class="headerlink" title="Hexo+Github发文原理"></a>Hexo+Github发文原理</h3><h2 id><a href="#" class="headerlink" title></a><img src="//wsmiley.github.io/2019/07/18/Hexo-Github构建个人博客/Hexo%E5%8F%91%E6%96%87%E5%8E%9F%E7%90%86.png" alt="Hexo发文原理"></h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a><strong>环境搭建</strong></h3><ul><li>Node.js       <a href="https://nodejs.org/" target="_blank" rel="noopener">https://nodejs.org/</a></li><li>Git         <a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></li><li>Github账号  <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></li></ul><h4 id="Github创建仓库"><a href="#Github创建仓库" class="headerlink" title="Github创建仓库"></a>Github创建仓库</h4><p>建立与用户名对应的仓库，仓库名必须为[username.github.io]。</p><p><img src="//wsmiley.github.io/2019/07/18/Hexo-Github构建个人博客/Github%E4%BB%93%E5%BA%93.png" alt="Github仓库"></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>在本地创建一个文件夹。</p><p>进入命令行</p><blockquote><p>npm install -g hexo-cli</p></blockquote><p>安装完毕后 </p><blockquote><p>hexo init &lt; folder &gt;</p></blockquote><p>&lt; folder &gt;是名称</p><p>新建完成后</p><p>指定文件夹的目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p><img src="//wsmiley.github.io/2019/07/18/Hexo-Github构建个人博客/hexo%E5%91%BD%E4%BB%A4.png" alt="hexo命令"></p><h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><p>网站的 配置 信息，您可以在此配置大部分的参数。</p><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><p>应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;hexo&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;hexo&quot;: &quot;^3.8.0&quot;,</span><br><span class="line">    &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,</span><br><span class="line">    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class="line">    &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;,</span><br><span class="line">    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,</span><br><span class="line">    &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;,</span><br><span class="line">    &quot;hexo-server&quot;: &quot;^0.3.3&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h4><p>模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p><p>Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p><h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><p>资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p><h4 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h4><p>主题 文件夹。Hexo 会根据主题来生成静态页面。</p><blockquote><p>在hexo init目录下<br><br>$ hexo server     //在本地起一个server</p></blockquote><p><img src="//wsmiley.github.io/2019/07/18/Hexo-Github构建个人博客/hexoserver%E5%91%BD%E4%BB%A4.png" alt="hexoserver命令"></p><p>在chrome输入localhost:4000,可看到配置好的Hexo页面</p><h2 id="将Hexo与Github联接起来"><a href="#将Hexo与Github联接起来" class="headerlink" title="将Hexo与Github联接起来"></a>将Hexo与Github联接起来</h2><ul><li>配置Git</li><li>配置Deployment</li></ul><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>在命令行下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br><span class="line">$ git config --global user.name &quot;your username&quot;</span><br><span class="line">$ git config --global user.email youremail@example.com</span><br></pre></td></tr></table></figure><p>在用户目录下查找.ssh文件夹,里面有id_rsa(私钥),id_rsa.pub(公钥)两个文件。</p><p>登入Githu,打开“Account settings”，“SSH Keys”页面，然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容，即可。</p><blockquote><p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p></blockquote><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>在_config.yml文件中,找到Deploy,修改格式如下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line"></span><br><span class="line">     type: git</span><br><span class="line"></span><br><span class="line">     repo: https://github.com/WSmiley/WSmiley.github.io.git</span><br><span class="line"></span><br><span class="line">     branch: master</span><br></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>成功后Github仓库<br><img src="//wsmiley.github.io/2019/07/18/Hexo-Github构建个人博客/Github%E9%A1%B5%E9%9D%A2.png" alt="Github页面"></p><blockquote><p>浏览器输入<a href="http://WSmiley.github.io/">http://WSmiley.github.io/</a></p></blockquote><h2 id="Hexo主题"><a href="#Hexo主题" class="headerlink" title="Hexo主题"></a>Hexo主题</h2><p>执行如下命令</p><blockquote><p>npm install –save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</p></blockquote><p>在_config.yml文件中,找到Scheme</p><blockquote><p>theme: melody # 将主题设置成melody</p></blockquote><p>melody：<a href="https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/" target="_blank" rel="noopener">https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/</a></p><p>ocean：<a href="https://github.com/zhwangart/hexo-theme-ocean" target="_blank" rel="noopener">https://github.com/zhwangart/hexo-theme-ocean</a></p><p><strong>需要git clone相应的项目</strong></p><p>验证设置主题,执行命令</p><blockquote><p>hexo server</p></blockquote><p>在chrome输入 localhost:4000</p><hr><h2 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h2><p>每次部署前建议操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line"></span><br><span class="line">$ hexo generate</span><br><span class="line"></span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>其他命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new&quot;postName&quot; #新建文章</span><br><span class="line">hexo new page&quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</span><br><span class="line">hexo deploy #将.deploy目录部署到GitHub</span><br><span class="line">hexo help # 查看帮助</span><br><span class="line">hexo version #查看Hexo的版本</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="如何在markdown加入图片"><a href="#如何在markdown加入图片" class="headerlink" title="如何在markdown加入图片"></a>如何在markdown加入图片</h3><p>_config.yml 里的post_asset_folder:这个选项设置为true</p><blockquote><p>post_asset_folder:true</p></blockquote><p>_config.yml 里修改URL避免github中图片引用路径出现问题</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">##If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; &gt;and root as &apos;/child/&apos;</span><br><span class="line">url: http://wsmiley.github.io</span><br><span class="line">root: /</span><br></pre></td></tr></table></figure><p>在你的hexo目录下执行</p><blockquote><p>npm install hexo-asset-image –save</p></blockquote><p>当你新建文章时,会出现同名文件夹</p><blockquote><p>hexo n “xxx”</p></blockquote><p>最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：</p><h5 id="你想输入的替代文字-xxxx-图片名-jpg"><a href="#你想输入的替代文字-xxxx-图片名-jpg" class="headerlink" title="![你想输入的替代文字] (xxxx/图片名.jpg)"></a>![你想输入的替代文字] (xxxx/图片名.jpg)</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hexo&quot;&gt;&lt;a href=&quot;#Hexo&quot; class=&quot;headerlink&quot; title=&quot;Hexo&quot;&gt;&lt;/a&gt;Hexo&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
    
  </entry>
  
</feed>
