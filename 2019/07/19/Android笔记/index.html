<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Android笔记"><meta name="keywords" content><meta name="author" content="Smiley"><meta name="copyright" content="Smiley"><title>Android笔记 | Smiley</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Android笔记"><span class="toc-number">1.</span> <span class="toc-text">Android笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#关于Android的小结"><span class="toc-number">1.1.</span> <span class="toc-text">关于Android的小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#活动Activity"><span class="toc-number">1.2.</span> <span class="toc-text">活动Activity</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UI"><span class="toc-number">1.3.</span> <span class="toc-text">UI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#广播机制"><span class="toc-number">1.4.</span> <span class="toc-text">广播机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据存储——持久化技术"><span class="toc-number">1.5.</span> <span class="toc-text">数据存储——持久化技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文件存储"><span class="toc-number">1.5.1.</span> <span class="toc-text">文件存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SharedPreferences存储"><span class="toc-number">1.5.2.</span> <span class="toc-text">SharedPreferences存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQLite数据库存储"><span class="toc-number">1.5.3.</span> <span class="toc-text">SQLite数据库存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LitePal操作数据库"><span class="toc-number">1.5.4.</span> <span class="toc-text">LitePal操作数据库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内容提供器"><span class="toc-number">1.6.</span> <span class="toc-text">内容提供器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#运行时权限"><span class="toc-number">1.6.1.</span> <span class="toc-text">运行时权限</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#运行时申请权限"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">运行时申请权限</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问其他程序中的数据"><span class="toc-number">1.6.2.</span> <span class="toc-text">访问其他程序中的数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ContentResolver类"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">ContentResolver类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建自己的内容提供器"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">创建自己的内容提供器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运用手机多媒体"><span class="toc-number">1.7.</span> <span class="toc-text">运用手机多媒体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通知"><span class="toc-number">1.7.1.</span> <span class="toc-text">通知</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建通知"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">创建通知</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP协议"><span class="toc-number">1.8.</span> <span class="toc-text">HTTP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解析XML格式数据"><span class="toc-number">1.8.1.</span> <span class="toc-text">解析XML格式数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XML解析"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">XML解析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#PULL解析"><span class="toc-number">1.8.1.1.1.</span> <span class="toc-text">PULL解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SAX解析"><span class="toc-number">1.8.1.1.2.</span> <span class="toc-text">SAX解析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON解析"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">JSON解析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JSONObject"><span class="toc-number">1.8.1.2.1.</span> <span class="toc-text">JSONObject</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GSON"><span class="toc-number">1.8.1.2.2.</span> <span class="toc-text">GSON</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务"><span class="toc-number">1.9.</span> <span class="toc-text">服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android多线程编程"><span class="toc-number">1.9.1.</span> <span class="toc-text">Android多线程编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AsyncTask-抽象类"><span class="toc-number">1.9.2.</span> <span class="toc-text">AsyncTask:抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务的基本用法"><span class="toc-number">1.9.3.</span> <span class="toc-text">服务的基本用法</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://cn.bing.com/th?id=OIP.GGMMu1oe3Cqby3tKJJ6DcgHaHW&amp;pid=Api&amp;rs=1"></div><div class="author-info__name text-center">Smiley</div><div class="author-info__description text-center">Personal Blog</div><div class="follow-button"><a href="https://github.com/Wsmiley">Follw Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">7</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://img18.3lian.com/d/file/201709/14/fbf49f60bc1912277ca0aa46db1499e0.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Smiley</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Android笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-19</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="Android笔记"><a href="#Android笔记" class="headerlink" title="Android笔记"></a>Android笔记</h1><blockquote>
<p>学习Android时候，做的一些笔记</p>
</blockquote>
<hr>
<h2 id="关于Android的小结"><a href="#关于Android的小结" class="headerlink" title="关于Android的小结"></a>关于Android的小结</h2><p>Andriod分为四个框架<br></p>
<ul>
<li>Linux内核层</li>
<li>系统运行层</li>
<li>应用框架层</li>
<li>应用层</li>
</ul>
<p>四大组件<br></p>
<ul>
<li>活动(包含用户界面，主要用于和用户交互)</li>
<li>服务</li>
<li>广播接收器</li>
<li>内容提供器</li>
</ul>
<p>工程Project文件解释<br><br>1、gradle目录（包含了gradle wrapper的配置文件,使用gradle wrapper的方式不需要提前将gradle下载好，而是会根据本地缓存情况决定是否需要联网下载</p>
<ul>
<li>.gitignore  指定的目录或文件排除在版本控制之外</li>
<li>build.gradle 项目全局的gradle构建脚本</li>
<li>gradle.properties 全局的gradle配置文件，影响所有gradle编译</li>
<li>local.properties 指定本机中的Android SDK路径</li>
<li>settings.gradle 指定项目中所有引入的模块</li>
</ul>
<p>2、App目录</p>
<ul>
<li>libs 第三方jar包，该目录下的jar包会自动添加到构建路径里</li>
<li>res目录图片(drawable)布局(layout)字符串、颜色、样式(values)、mipmap(图标)</li>
<li>AndroidManifest.xml 配置文件</li>
</ul>
<p>日志工具<br><br>方法<br></p>
<blockquote>
<p>Log.v() 打印琐碎的、意义最小的日志信息。对应级别是verbose</p>
</blockquote>
<blockquote>
<p>Log.d() 打印一些调试信息，这些信息对你的调试程序和分析问题有帮助。对应级别是debug</p>
</blockquote>
<blockquote>
<p>Log.i() 打印一些比较重要的数据，可分析用户行为。对应级别info</p>
</blockquote>
<blockquote>
<p>Log.w() 打印一些警告信息，某个地方存在潜在风险。对应级别warn</p>
</blockquote>
<blockquote>
<p>Log.e() 打印程序的错位信息。对应级别error</p>
</blockquote>
<hr>
<h2 id="活动Activity"><a href="#活动Activity" class="headerlink" title="活动Activity"></a>活动Activity</h2><hr>
<p>1、手动创建活动</p>
<blockquote>
<p>Add No Activity</p>
</blockquote>
<blockquote>
<p>app/src/main/java/com.example.actitvitytest目录为空</p>
</blockquote>
<blockquote>
<p>New - Activity - Empty Activity</p>
</blockquote>
<blockquote>
<p>Generate Layout File:创建对应布局文件</p>
</blockquote>
<blockquote>
<p>Launcher Activity:设置当前创建活动为主活动</p>
</blockquote>
<blockquote>
<p>Backwards Compatibilitiy:项目启用向下兼容模式</p>
</blockquote>
<p>2、创建和加载布局</p>
<li> <strong>创建布局文件

<blockquote>
<p>app/src/main/res</p>
</blockquote>
<blockquote>
<p>New - Directory -创建layout目录 - New - Layout resource file</p>
</blockquote>
<blockquote>
<p>布局元素属性值 match_parent:当前元素与父元素一样宽 wrap_content:   当前元素的高度能刚好包含里面的内容</p>
</blockquote>
<li><strong>在AndroidManifest文件中注册

<blockquote>
<p>注册声明放在&lt; application &gt;标签内，通过&lt; activity &gt;标签来对活动注册</p>
</blockquote>
<blockquote>
<p>&lt; intent-filter &gt;标签理解为过滤器，它指定了启动应用程序的Intent对象的动作和类型<br>&lt; action android:name=”android.intent.action.MAIN”/<br>&lt; category android:name=”android.intent.category.LAUNCHER”/&gt;</p>
</blockquote>
<li>Toast:提醒方式

<blockquote>
<p>Toast.makeText( FirstActivity.this, string, Toast.LENGTH_SHORT).show()</p>
</blockquote>
<blockquote>
<p>//makeText创建出一个Toast对象，调用show()方法将Toast显示出来。</p>
</blockquote>
<p>第一个参数context(Toast要求的上下文，活动本身就是一个context对象)。第二个参数(Toast显示文本对象)。第三个参数(显示时长)</p>
</li><li>Menu

<blockquote>
<p>res目录 - New - Directory - Menu - New - Menu resource file</p>
</blockquote>
<blockquote>
<p>&lt; item &gt;标签用来创建具体的某一个菜单项</p>
</blockquote>
<blockquote>
<p>Ctrl+O 重写 onCreateOptionsMenu()方法</p>
</blockquote>
<blockquote>
<p>getMenuInflater()方法得到MenuInflater对象，调用它的inflate()方法给当前活动创建菜单。inflate() 第一个参数指定通过哪个资源文件来创建菜单中。第二个参数用于指定我们的菜单项将添加到哪一个Menu对象中</p>
</blockquote>
<blockquote>
<p>响应菜单重写onOptionsSelected()方法,调用item.getItemId()判断点击哪个菜单项</p>
</blockquote>
<p>3、<strong>Intent:各组件之间进行交互，不同组件之间传递数据</strong></p>
</li><li>显式Intent

<blockquote>
<p>Intent(Cotext packageContext,Class&lt;?&gt;cls)<br>//第一个参数Context要求提供一个启动活动的上下文。第二个参数Class则是指定想要启动的目标活动(意图)</p>
</blockquote>
<blockquote>
<p>startActivity()方法启动活动。</p>
</blockquote>
</li><li>隐式Intent

<blockquote>
<p>指定一系列更为抽象的action和category等信息，然后交由系统去分析这个Intent，找到合适的活动去启动</p>
</blockquote>
<blockquote>
<p>在AndroidManifest.xml文件中&lt; action &gt;和&lt; category &gt;有关</p>
</blockquote>
<pre><code>1、打开浏览器
    Intent intent = new Intent(Intent.ACTION_VIEW);
    intent.setData(Uri.parse(&quot;url&quot;));//Uri.parse方法将网址字符串解析成一个对象,用setData方法将Uri对象传进去
    startActivity(intent);

2、拨号
    Intent intent = new Intent(Intent.ACTION_DIAL);
    intent.setData(Uri.parse(&quot;tel:10086&quot;));//geo表示地理位置
    startActivity(intent);

3、向下一个活动传递数据
    //传值       
    String data = &quot;Hello world&quot;;
    Intent intent = new Intent(Activity.this,Acitivity.class);
    intent.putExtra(&quot;extra_data&quot;,data);//第一个参数是键，第二个参数是取值
    startAcitvity(intent);

    //取值
    Intent intent = getIntent();//getIntent()方法得到上一个活动的Intent
    String data = intent.getStringExtra(&quot;extra_data&quot;);//调用getStringExtra()传入相应的键值，来获得传递的数据

4、返回数据给上一个活动
    Intent intent = new Intent(Activity.this,Activity.class);
    startActivityForResult(intent,1);//第一个参数Intent，第二个参数是请求码，用于判断在之后的回调中判断数据的来源

    Intent intent = new Intent();
    intent.putExtra(&quot;data_return&quot;,&quot;hello world&quot;);
    setResult(RESULT_OK,intent);//专门用于向上一个活动返回数据的。第一个参数用于向上一个活动返回处理结果的。第二个参数是把带有数据的Intent传递回去
    finish();

    //重写onActivityResult()方法
    onActivityResult(int requestCode,int resultCode,Intent data)
    //第一个参数:启动活动时传入的请求码。第二个参数:返回数据时传入的处理结果。第三个参数:携带返回数据的Intent。

    //重写onBackPressed()方法</code></pre><p>4、活动的生命周期(返回栈)</p>
<ul>
<li>活动状态<ul>
<li>运行状态</li>
<li>暂停状态</li>
<li>停止状态</li>
<li>销毁状态</li>
</ul>
</li>
<li>活动的生存期<ul>
<li>onCreate() :活动第一次被创建调用</li>
<li>onStart() :活动由不可见变为可见调用</li>
<li>onResume() :活动准备好和用户进行交互时调用，此活动一定位于返回栈的栈顶，并处于运行状态</li>
<li>onPause() :系统准备启动/恢复另一个活动的时候调用</li>
<li>onStop() :活动完全不可见时调用</li>
<li>onDestroy() :活动被销毁之前调用</li>
<li>onRestart() :活动由停止状态变为运行状态之前调用</li>
</ul>
</li>
</ul>
<p>5、活动的启动模式</p>
<p>在AndroidManifest.xml中通过&lt; activity &gt;标签指定android.lanunchMode属性来选择启动模式 </p>
<blockquote>
<p>standard：活动默认启动模式.对于standard模式启动的活动，系统不在乎这个是否在返回栈中存在，每次启动都会创建该活动的一个新实例</p>
</blockquote>
<blockquote>
<p>singleTop：启动活动时，若发现返回栈的栈顶是该活动，默认使用该活动，不再创建新实例</p>
</blockquote>
<blockquote>
<p>singleTask 每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现则之间使用该实例，并把活动之上的所有活动统统出栈。如果没有发现就会创建一个新的活动实例</p>
</blockquote>
<blockquote>
<p>singleInstance：启动一个新的返回栈管理这个活动。</p>
</blockquote>
<hr>
<h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><ul>
<li>控件（TextView,Button,EditText,ImageView,ProgressBar,AlerDialog,ProgressDialog)</li>
<li>布局<br>  1、线性布局(LinearLayout)<br>  2、相对布局(RelativeLayout)<br>  3、帧布局(FrameLayout)<br>  4、百分比布局(PercentFrameLayout)(PercentRelativeLayout)</li>
<li>自定义控件</li>
</ul>
<hr>
<h2 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h2><ul>
<li>标准广播 : 完全异步执行的广播，没有先后顺序，几乎同时收到。</li>
<li>有序广播 : 同步执行的广播，同一时刻只有一个广播接收器能够收到这条广播，当广播接收器中的逻辑执行完后，广播才继续（有优先级、可截断）</li>
</ul>
<p>需要进行一些敏感操作，必须在配置文件(AndroidManifest.xml)中声明权限</p>
<p>1、系统广播</p>
<ul>
<li>动态注册：代码中注册。</li>
</ul>
<blockquote>
<p>新建一个类继承BroadcastReceiver，重写onReceive()方法。</p>
</blockquote>
<blockquote>
<p>动态注册的广播接收器一定都要取消注册。 在onDestroy()方法中调用unregisterReceiver()方法实现。</p>
</blockquote>
<ul>
<li>静态注册：在AndroidManifest.xml中注册</li>
</ul>
<blockquote>
<p>&lt; application &gt;标签内 &lt; receiver &gt;所有静态的广播接收器都是在这里注册的</p>
</blockquote>
<p>不要在onReceive()方法中添加过多的逻辑或者进行任何耗时操作，因为广播接收器是不允许开启线程的，当onReceive()方法运行过长时间而没有结束，程序就会报错。</p>
<p>2、本地广播：广播只在应用程序内部传递，广播接收器也只接收来自本应用程序发出的广播。（安全性）。无法通过静态注册的方式接收。</p>
<blockquote>
<p>LocalBroadcastManager //对广播进行管理，并提供了发生广播和注册广播接收器的方法。</p>
</blockquote>
<hr>
<h2 id="数据存储——持久化技术"><a href="#数据存储——持久化技术" class="headerlink" title="数据存储——持久化技术"></a>数据存储——持久化技术</h2><p>简介：数据持久化就是指那些内存中的瞬时数据保存到数据存储设备中，保证即使在手机或电脑关机的情况下，这些数据仍不会丢失。持久化技术提供了一种机制可以让数据在瞬时状态和持久之间进行转换。</p>
<ul>
<li>文件存储</li>
<li>SharedPreferences存储</li>
<li>数据库存储</li>
</ul>
<h3 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h3><p>特点：不对存储的内容进行任何的格式化处理，所有数据都是原封不动地保存到文件中，因而比较适合用于存储一些简单的文本数据或二进制数据。</p>
<p>1、将数据存储到文件中</p>
<blockquote>
<p>Context类提供了一个openFileOutput()方法,用于将数据存储到指定的文件中。第一个参数文件名(不可以包含路径)，所有文件默认存储到/data/data/&lt; package name &gt;/files/。第二个参数是文件的操作模式.MODE_PRIVATE/MODE_APPEND。返回一个FileOutputStream对象，得到对象后用Java流的方式将数据写入文件。</p>
</blockquote>
<p>2、从文件中读取数据</p>
<blockquote>
<p>Context类提供一个openFileInput()方法，用于从文件中读取数据。只接收一个参数，要读取的文件名。返回一个FileInputStream对象。得到对象之后通过Java流的方式将数据读取。</p>
</blockquote>
<h3 id="SharedPreferences存储"><a href="#SharedPreferences存储" class="headerlink" title="SharedPreferences存储"></a>SharedPreferences存储</h3><p>特点:利用键值对的方式存储数据，支持多种不同的数据类型存储。</p>
<blockquote>
<p>首先得到SharedPreferences对象</p>
</blockquote>
<ul>
<li>有三种方法得到sharedPreferences对象</li>
</ul>
<p>1、Context类中的getSharedPreferences()方法，此方法接收两个参数。第一个参数用于指定SharedPreferences文件的名称；如果指定不存在，则会创建一个。SharedPreferences文件存放在/data/data/&lt; package name &gt;/shared_prefs/目录下。第二个参数用于指定操作模式：MODE_PRIVATE</p>
<p>2、Activity类中的getpreferences()方法<br>与Context中getPreferences方法类似。不过它只接收一个操作模式参数，这个方法会自动将当前活动的类名作为SharePrefereces的文件名。</p>
<p>3、PreferenceManager类中的getDefaultSharedPreferences()方法<br>这是一个静态方法。接收一个Context参数，并自动使用当前应用程序的包名作为前缀来命名SharedPreference文件。<br>分为三步</p>
<ul>
<li>调用SharedPreferences对象的Edit()来获取一个SharedPreferences.Editor对象。</li>
<li>向SharedPreferences.Editor对象中添加数据。</li>
<li>调用apply()方法将添加的数据提交，从而完成数据存储操作</li>
</ul>
<h3 id="SQLite数据库存储"><a href="#SQLite数据库存储" class="headerlink" title="SQLite数据库存储"></a>SQLite数据库存储</h3><p>Android内置数据库SQLite，有专门管理数据库的一个类SQLiteOpenHelper(抽象类)帮助类</p>
<blockquote>
<p>首先创建一个自己的帮助类继承SQLiteOpenHelper抽象类</p>
</blockquote>
<blockquote>
<p>SQLiteOpenHelper有两个抽象方法。在自己的帮助类重写onCreate()方法和onUpgrade()方法</p>
</blockquote>
<blockquote>
<p>SQLiteOpenHelper两个实例方法：getReadableDatabase()和getWritableDatabase()。<br>两个方法可以创建/打开一个现有的数据库(存在打开，否则创建)，并且返回一个可对数据库进行读写操作的对象SQLiteDatabase。</p>
</blockquote>
<p>不同:当数据库不可写入时，getReadableDatabase()方法返回的对象将以只读的方式打开数据库。getWritableDatabase()方法则出现异常。</p>
<h3 id="LitePal操作数据库"><a href="#LitePal操作数据库" class="headerlink" title="LitePal操作数据库"></a>LitePal操作数据库</h3><p>简介:Litepal是一款开源的Android数据库框架,采用对象关系映射(ORM)的模式,并将平时开放最常用到的一些数据库功能进行封装。<a href="https://github.com/LitePalFramework/LitePal" target="_blank" rel="noopener">https://github.com/LitePalFramework/LitePal</a></p>
<ul>
<li>配置LitePal</li>
</ul>
<blockquote>
<p>app/built.gradle——dependecies闭包中添加<br>dependencies{<br>mplementation ‘org.litepal.android:java:3.0.0’<br>}</p>
</blockquote>
<ul>
<li>配置Litepal.xml文件<blockquote>
<p>app/src/main——new-Directory创建一个assets目录-创建litepal.xml文件</p>
</blockquote>
</li>
</ul>
<p>编辑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt; litepal &gt;</span><br><span class="line">    &lt; dbname value=&quot;bookStore&quot;&gt;&lt; /dbname&gt; //用于指定数据库名</span><br><span class="line">    &lt; version value=&quot;1&quot;&gt;&lt; /version&gt;   //用于指定数据库版本号</span><br><span class="line">    &lt; list&gt;  //用于指定所有的映射模型</span><br><span class="line">    &lt; /list&gt;</span><br><span class="line">&lt; /litepal&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>编辑AndroidmaniFest.xml文件<blockquote>
<p>&lt; application<br>  android:name=”org.litepal.LitePalApplication&gt;</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="内容提供器"><a href="#内容提供器" class="headerlink" title="内容提供器"></a>内容提供器</h2><p>简介:内容提供器主要用于在不同的应用程序之间实现数据共享的功能。它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保住被访问数据的安全性。（可以选择只对哪一部分数据进行共享</p>
<p>用法：(1)使用现有的内容提供器来读取和操作相应程序中的数据。(2)创建自己的内容提供器给程序的数据提供外部访问接口。</p>
<h3 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h3><ul>
<li>普通权限</li>
<li>特殊权限</li>
<li>危险权限</li>
</ul>
<p>完整权限列表 http//developer.android.google.cn/reference/android/Manifest.permission.html</p>
<h4 id="运行时申请权限"><a href="#运行时申请权限" class="headerlink" title="运行时申请权限"></a>运行时申请权限</h4><p>AndroidManifest.xml</p>
<blockquote>
<p>&lt; uses-permission android:name=””&gt;</p>
</blockquote>
<p>MainActivity——逻辑<br>第一步判断是否拥有权限</p>
<blockquote>
<p>ContextCompat.checkSelfPermission()方法。接收两个参数，第一个参数Context。第二个参数是具体的权限名，然后返回值和PackageManager.xxx做比较</p>
</blockquote>
<p>若无权限</p>
<blockquote>
<p>调用ActivityCompat.requestPermission()方法来向用户申请权限。接收三个参数。第一个参数是Activity的实例；第二个参数是String数组，把申请的权限名放在数组中；第三个参数是请求码，要求唯一值。</p>
</blockquote>
<h3 id="访问其他程序中的数据"><a href="#访问其他程序中的数据" class="headerlink" title="访问其他程序中的数据"></a>访问其他程序中的数据</h3><h4 id="ContentResolver类"><a href="#ContentResolver类" class="headerlink" title="ContentResolver类"></a>ContentResolver类</h4><p>用法:想要访问内容提供器中共享的数据，必须借助ContentResolver类，通过Context中的getContentResolver()方法获取该到该类的实例。ContentResolver中提供了一系列的方法用于对数据进行CRUD操作</p>
<ul>
<li>insert()添加数据</li>
<li>updata()更新数据</li>
<li>delete()删除数据</li>
<li>query()查询数据</li>
</ul>
<p>ContentResolver中的增删改查不接收表名参数，接收一个Uri参数(内容URI:表达了哪个程序中的哪张表里的数据)。<br>内容URI给内容提供器建立了唯一的标识符。由两部分组成：authority和path。<br>authority:用于对不同的应用程序做区分，一般为了避免冲突，都会采用程序包名的方式来进行命名。<br>path:用于对同一张表table1和table2，可以用path分别命名为/table1和table2,然后把authority和path进行组合。</p>
<p>得到内容URI字符串后，将它解析成Uri对象才可以做为参数传入。调用Uri.parse()方法，就可以将内容URI字符串解析成Uri对象</p>
<blockquote>
<pre><code>Uri uri=Uri.parse(&quot;content:comple.app.provider/table1&quot;)
Cursor cursor=getContentResolver().query(
uri,//指定某个应用程序下的某一张表
projection,//查询的列名
selection,//where的约束条件
selectionArgs,//where中的占位符提供具体的值
sortorder);//查询结果的排序方式</code></pre></blockquote>
<p>查询结果返回一个Cursor对象，数据可以从Cursor对象中逐个读取出来了。</p>
<h4 id="创建自己的内容提供器"><a href="#创建自己的内容提供器" class="headerlink" title="创建自己的内容提供器"></a>创建自己的内容提供器</h4><p>新建一个类去继承ContenProvider：有六个抽象方法<br></p>
<ul>
<li>onCreate():初始化内容提供器时调用。通常会在这里完成对数据库的创建和升级操作</li>
<li>query():从内容提供器中查询数据。uri确定查询哪张表，projection确定查询哪些列，selection和selectionArgs用于约束哪些行，sortorder用于对结果进行排序，查询结果存放在Cursor对象中返回。</li>
<li>insert():向内容提供器中添加一条数据。使用uri参数来确定添加到的表，待添加的数据保存在values参数中，添加完成后，返回一个用于表示这条新数据的URI</li>
<li>update():更新内容提供器的已有数据。使用uri参数来确定更新表中那些数据，待添加的数据保存在values参数中，selection和selectionArgs用于约束更新哪些行，受影响的行数将作为返回值返回。</li>
<li>delete():从内容提供器中删除数据。uri确定删除哪张表中的数据，selection和selectionArgs用于约束删除哪些行，被删除的行数将作为返回值返回。</li>
<li>getType():根据传入进入的内容URI来返回相应的MIME类型。</li>
</ul>
<p>MIME类型字符串由三部分组成。格式</p>
<ul>
<li>必须以vnd开头。</li>
<li>如果内容URI以路径结尾，则后接android.cursor.dir/；如果以id结尾,则后接android.cursor.item/</li>
<li>最后接上vhd.&lt; authoriy &gt;.&lt; path &gt;</li>
</ul>
<p>内容URI的格式,以路径结尾就表示期望访问该表中所有的数据，以id结尾就表示期望访问该表中拥有相应id的数据。<br><br>通配符<br><br>*:表示匹配任意长度字符。<br></p>
<p>#：表示匹配任意长度的数字。</p>
<blockquote>
<p>content://com.exmaple.app.provider/table1/#</p>
</blockquote>
<p>UriMatcher类:实现匹配内容URI的功能。</p>
<p>uriMatcher.addURI()方法：接收三个参数，authority,path和一个自定义代码。</p>
<p>uriMatcher.match()方法:传入一个Uri对象，返回值是某个能够匹配这个Uri对象所对应的自定义代码，利用这个代码可以判断出调用方期望访问的哪张表中的数据了。</p>
<p>跨程序访问不能直接使用Toast。</p>
<hr>
<h2 id="运用手机多媒体"><a href="#运用手机多媒体" class="headerlink" title="运用手机多媒体"></a>运用手机多媒体</h2><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><h4 id="创建通知"><a href="#创建通知" class="headerlink" title="创建通知"></a>创建通知</h4><p>1、首先需要一个NotificationManager对通知进行管理，调用Context的getSystemService()方法获得。getSystemService()接收一个字符串参数用于确定获取系统的哪个服务。</p>
<blockquote>
<p>NotificationManager manager=(NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);</p>
</blockquote>
<p>2、接下来使用一个Builder构造器来创建Notification对象。support-v4库中提供了一个NotificationCompat类，使用这个类的构造器创建Notification对象。</p>
<blockquote>
<p>Notification notification=new NotificationCompat.Builder(context).build();</p>
<ul>
<li>setContentTitle(“”):通知的标题</li>
<li>setContext(“”):通知的正文内容</li>
<li>SetWhen():通知被创建的时间</li>
<li>SetSmallIcon():设置通知的小图标，注意只能使用纯alpha图层的图片进行设置(状态栏)</li>
<li>SetLargeIcon():设置通知的大图标。(下拉)</li>
</ul>
</blockquote>
<p>完成后只要调用NotificationManager的notify()方法就可以让通知显示出来，接收两个参数，第一个参数id：保证每个通知所指定的id都是不同的。第二个参数是Notification对象。</p>
<hr>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>Android发送HTTP请求:HttpURLConnection和OkHttp</p>
<p>###HttpURLConnection<br>获取HttpURLConnection实列</p>
<blockquote>
<p>URL url=new URL(“http://…”);<br>HttpURLConnection connection=(HttpURLConnection)url.openConnection();</p>
</blockquote>
<p>得到HttpURLConnection实例后，设置HTTP请求所用的方法，GET和POST。</p>
<ul>
<li>GET：从服务器中获取数据</li>
<li>POST：提交数据给服务器<blockquote>
<p>connection.setRequestMethod(“GET”);</p>
</blockquote>
</li>
</ul>
<p>其他定制：例如设置连接超时，读取超时的毫秒数，以及服务器希望得到的一些消息头。</p>
<blockquote>
<p>connection.setConnectTimeout(8000);<br>connection.setReadTimeout(8000);</p>
</blockquote>
<p>调用getInpuStream()方法获取到服务器返回的输入流.</p>
<blockquote>
<p>InpuStream in=connection.getInputStream();</p>
</blockquote>
<p>用disconnect()方法将这个HTTP连接关闭掉</p>
<blockquote>
<p>connection.disconnect();</p>
</blockquote>
<p>控件：ScrollView：滚动形式查看屏幕外的内容</p>
<p>###OkHttp<br>项目地址<a href="http://github.com/square/okhttp" target="_blank" rel="noopener">http://github.com/square/okhttp</a><br>添加Okhttp库依赖<br>编辑app/build.gradle文件<br>在dependencies闭包中添加</p>
<blockquote>
<pre><code> dependencies{
       implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])
       implementation &apos;com.android.support:appcompat-v7:28.0.0&apos;
       testImplementation &apos;junit:junit:4.12&apos;
       implementation &apos;com.squareup.okhttp3:okhttp:3.13.1 &apos;
}</code></pre></blockquote>
<p>创建一个OkHttpClient的实例</p>
<blockquote>
<p>OkHttpClient client=new OkHttpClient();</p>
</blockquote>
<p>发起一条HTTP请求，需要创建Request对象</p>
<blockquote>
<p>Request request=new Request.Builder().build();//创建空的Request对象.<br>可以在build()前连缀很多其他方法丰富Request对象</p>
</blockquote>
<p>之后调用OkHttpClient的newCall()方法创建一个call对象，并调用它的execute()方法来发送请求并获取服务器返回的数据。Response对象就是服务器返回的数据了。</p>
<blockquote>
<p>Response response=client.newCall(request).execute()<br>String responseData=response.body().string();</p>
</blockquote>
<p>POST请求<br>首先构建一个RequestBody对象存放待提交的参数。</p>
<blockquote>
<p>RequestBody requestBody=new FormBody,Builder().add(“username”,”admin”).add(“password”,”123456”).build();</p>
</blockquote>
<p>然后在Request.Builder中调用一下post()方法，并将RequestBody()对象传入。</p>
<blockquote>
<p>Request request=new Request.Builder().url(“<a href="http://www.baidu.com&quot;).post(requestBody).build()" target="_blank" rel="noopener">http://www.baidu.com&quot;).post(requestBody).build()</a>;</p>
</blockquote>
<p>调用execute()方法来发送请求获取服务器返回的数据。</p>
<h3 id="解析XML格式数据"><a href="#解析XML格式数据" class="headerlink" title="解析XML格式数据"></a>解析XML格式数据</h3><p>网上常用格式:XML和JSON  （DOM解析方法）</p>
<h4 id="XML解析"><a href="#XML解析" class="headerlink" title="XML解析"></a>XML解析</h4><h5 id="PULL解析"><a href="#PULL解析" class="headerlink" title="PULL解析"></a>PULL解析</h5><p>调用 parseXMLWithPull() 方法解析服务器返回的数据，传入服务器返回的数据。<br>首先获取一个XmlPullParserFactory的实例，并借助这个实例得到XmlPullParser对象，然后调用XmlPullParser的setInput()方法将服务器返回的XML数据设置进去进行解析。<br>解析过程：通过getEventType()得到当前解析事件，然后一个while循环中不断解析，如果当前解析事件不等于XmlPullParser.END_DOCUMENT,说明解析工作还没有完成,调用next()方法后可以获取下一个解析事件。</p>
<blockquote>
<pre><code>private void parseXMLWithPull(String xmlData){
    XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
    XmlPullParser xmlPullParser = factory.newPullParser();
    xmlPullParser.setInput(new StringReader(xmlData));
    int eventType = xmlPullParser.getEventType();
    while(eventType != XmlPullParser.END_DOCUMENT){
     ...
    }
}</code></pre></blockquote>
<h5 id="SAX解析"><a href="#SAX解析" class="headerlink" title="SAX解析"></a>SAX解析</h5><p>新建一个类继承DefaultHandler，并重写父类5个方法</p>
<ul>
<li>startDocumnet() :开始XML解析时调用</li>
<li>startElement() :开始解析某个节点的时候调用</li>
<li>characters() :获取节点中内容的时调用</li>
<li>endElement() :完成某个节点时候调用</li>
<li>endDocument() :完成整个XML解析时候调用</li>
</ul>
<h4 id="JSON解析"><a href="#JSON解析" class="headerlink" title="JSON解析"></a>JSON解析</h4><p>JSONObject(官方),GSON(Google),Jackson,FastJSON等</p>
<h5 id="JSONObject"><a href="#JSONObject" class="headerlink" title="JSONObject"></a>JSONObject</h5><p>将从服务器得到的数据返回到parseJSONWithJSONObject()中进行数据解析.<br>在该方法中将数据返回给一个JSONArray对象中，然后遍历循环这个JSONArray,从中取出每一个元素都是一个JSONObject对象。然后调用getString()方法将数据取出</p>
<blockquote>
<pre><code>  private void parseJSONWithJSONObject(String jsonData){
      try{
           JSONArray jsonArray = new JSONArray(jsonData);
           for(int i=0;i&lt;jsonArray.length();i++){
           JSONObject jsonobject=jsonArray.getJSONObject(i);
           ...
      }
  }
}</code></pre></blockquote>
<h5 id="GSON"><a href="#GSON" class="headerlink" title="GSON"></a>GSON</h5><p>添加GSON库的依赖，编辑app/build.gradle文件</p>
<blockquote>
<pre><code>dependencies{
     compile &apos;com.google.code.gson:gson:2.7&apos;             
}</code></pre></blockquote>
<p>JSON格式的数据如</p>
<blockquote>
<pre><code>{&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:20}</code></pre><p>定义一个Person类，加入name和age这两个字段，然后调用以下代码就可以将JSON数据自动解析成一个Person对象了<br>      Gson gson =new Gson();<br>      Person person = gson.fromJson(jsonData,person.class);</p>
</blockquote>
<p>如何解析的是一段JSON数组，借助TypeToken将期望解析成的数据类型传入到fromJson()方法中</p>
<blockquote>
<pre><code>List&lt; person &gt;people =gson.fromJson(jsonData,new TypeToken&lt;List&lt;Person&gt;&gt;(){}.getType());</code></pre></blockquote>
<hr>
<h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>服务是Android中实现程序后台运行的解决方案<br>不自动开启线程，所有代码默认运行在主线程中。</p>
<h3 id="Android多线程编程"><a href="#Android多线程编程" class="headerlink" title="Android多线程编程"></a>Android多线程编程</h3><p>定义一个线程只需要新建一个类继承自Thread。然后重写父类的run()方法，并在里面下逻辑</p>
<blockquote>
<pre><code>class MyThread extends Thread{
    public void run(){
    }
}</code></pre></blockquote>
<p>启动线程：new出MyThread的实例，然后调用start()方法</p>
<blockquote>
<pre><code>new MyThread().start()</code></pre></blockquote>
<p>使用继承耦合性(?)高，一般使用实现Runnable接口的方式定义一个线程</p>
<blockquote>
<pre><code>class MyThread implements Runnable{
    public void run(){
    }   
}</code></pre></blockquote>
<p>启动线程变不同</p>
<blockquote>
<pre><code>MyThread myThread = new MyThread();
new Thread(myThread).start();</code></pre></blockquote>
<p>不使用接口，使用匿名类</p>
<blockquote>
<pre><code>  new Thread(new Runnable){
       public void run(){
       }
}</code></pre></blockquote>
<p>UI无法在子线程里更新，对于这种情况Android提供了一套异步消息处理机制，使得可以在子线程里更新UI。</p>
<p>Android的异步消息处理主要由4部分组成:Message、Handler、MessageQueue和Looper.</p>
<ul>
<li><p>Message:在线程之间传递消息，它内部可以携带少量信息，用于不同线程之间交换数据。</p>
</li>
<li><p>Handler：主要用于发送和处理消息。发消息一般是Handler的sendMessage()方法，发出消息后最终传递到Handler的handleMessage()方法中</p>
</li>
<li><p>MessageQueue：消息队列，主要用于存放所有通过Handler发送的消息，这部分消息一直放在消息队列中，等待处理，每一个线程中只会有一个MessageQueue对象。</p>
</li>
<li><p>Looper:是每一个线程中MessageQueue的管理者，调用Looper的loop()方法后，就会进入到一个无限循环中，然后发现MessageQueue中存在一条消息，就会将它取出，传递到Handler的handleMessage()方法中，每一个线程中只有一个Looper对象。</p>
</li>
</ul>
<h3 id="AsyncTask-抽象类"><a href="#AsyncTask-抽象类" class="headerlink" title="AsyncTask:抽象类"></a>AsyncTask:抽象类</h3><p>AsyncTask,是android提供的轻量级的异步类,可以直接继承AsyncTask,在类中实现异步操作,并提供接口反馈当前异步执行的程度(可以通过接口实现UI进度更新),最后反馈执行的结果给UI主线程.</p>
<p>创建子类继承,继承时可以为AsyncTask类指定3个泛型参数</p>
<ul>
<li>Params:在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。比如HTTP请求的URL</li>
<li>Progress:后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位</li>
<li>Result:当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型.</li>
</ul>
<blockquote>
<pre><code>class DownloadTask extends AsyncTask&lt;void,Integer,Boolean&gt;{
    ...    
}</code></pre></blockquote>
<p>一般重写4个方法</p>
<ul>
<li>onPreExecute():这个方法在后台任务开始执行之前调用，用于进行一些界面上的初始化操作。比如显示一些进度条对话框</li>
<li>doInBackground(Params…):这个方法中的所有代码都会在子线程中运行，应该在这里去处理所有的耗时任务，通过return将任务的执行结果返回.如果AsyncTask的第三个参数是void，则可以不返回任务执行结果。这个方法不可以进行UI操作。如果需要更新UI元素，比如说反馈当前任务执行进度，调用publishProgress(Progress)方法完成。</li>
<li>onProgressUpdate(Progress…):当任务调用了publishProgress(Progress)后，此方法很快被调用，该方法中携带的参数就是后台任务中传递过来的。可以对UI进行操作，参数中的数值可对界面中的元素进行相应更新。</li>
<li>onPostExecute(Result):当后台任务执行完毕后并通过return语句进行返回时，该方法很快被调用，返回的数据会被作为参数传递到此方法中，可以利用返回的数据来进行一些UI操作，比如提醒任务执行的结果，以及关闭进度条对话框等。</li>
</ul>
<h3 id="服务的基本用法"><a href="#服务的基本用法" class="headerlink" title="服务的基本用法"></a>服务的基本用法</h3><blockquote>
<p>com.example.servicetest——New——Service——Service<br>Export：表示是否允许除了当前程序之外的程序访问该服务<br>Enalbe：是否启用这个服务</p>
</blockquote>
</li></strong></li></strong></li></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Smiley</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://wsmiley.github.io/2019/07/19/Android笔记/">http://wsmiley.github.io/2019/07/19/Android笔记/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://wsmiley.github.io">Smiley</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/07/20/Rpi搭建opencv环境/"><i class="fa fa-chevron-left">  </i><span>Rpi搭建opencv环境</span></a></div><div class="next-post pull-right"><a href="/2019/07/19/React/"><span>React</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://img18.3lian.com/d/file/201709/14/fbf49f60bc1912277ca0aa46db1499e0.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 By Smiley</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my blog</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>